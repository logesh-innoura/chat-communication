{"ast":null,"code":"/*! @azure/msal-common v14.6.0 2024-01-09 */\n'use strict';\n\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.mjs';\nimport { generateCredentialKey } from './utils/CacheHelpers.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from './entities/AccountEntity.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { updateAccountTenantProfileData, tenantIdMatchesHomeTenant } from '../account/AccountInfo.mjs';\nimport { extractTokenClaims } from '../account/AuthToken.mjs';\nimport { name, version } from '../packageMetadata.mjs';\nimport { getAliasesFromStaticSources } from '../authority/AuthorityMetadata.mjs';\nimport { invalidCacheRecord, bindingKeyNotRemoved, multipleMatchingAppMetadata, methodNotImplemented } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n * @internal\r\n */\nclass CacheManager {\n  constructor(clientId, cryptoImpl, logger, staticAuthorityOptions) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n    this.staticAuthorityOptions = staticAuthorityOptions;\n  }\n  /**\r\n   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\r\n   * @param accountFilter - (Optional) filter to narrow down the accounts returned\r\n   * @returns Array of AccountInfo objects in cache\r\n   */\n  getAllAccounts(accountFilter) {\n    return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter || {}), accountFilter);\n  }\n  /**\r\n   * Gets first tenanted AccountInfo object found based on provided filters\r\n   */\n  getAccountInfoFilteredBy(accountFilter) {\n    const allAccounts = this.getAllAccounts(accountFilter);\n    if (allAccounts.length > 1) {\n      // If one or more accounts are found, prioritize accounts that have an ID token\n      const sortedAccounts = allAccounts.sort(account => {\n        return account.idTokenClaims ? -1 : 1;\n      });\n      return sortedAccounts[0];\n    } else if (allAccounts.length === 1) {\n      // If only one account is found, return it regardless of whether a matching ID token was found\n      return allAccounts[0];\n    } else {\n      return null;\n    }\n  }\n  /**\r\n   * Returns a single matching\r\n   * @param accountFilter\r\n   * @returns\r\n   */\n  getBaseAccountInfo(accountFilter) {\n    const accountEntities = this.getAccountsFilteredBy(accountFilter);\n    if (accountEntities.length > 0) {\n      return accountEntities[0].getAccountInfo();\n    } else {\n      return null;\n    }\n  }\n  /**\r\n   * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters\r\n   * and builds the account info objects from the matching ID token's claims\r\n   * @param cachedAccounts\r\n   * @param accountFilter\r\n   * @returns Array of AccountInfo objects that match account and tenant profile filters\r\n   */\n  buildTenantProfiles(cachedAccounts, accountFilter) {\n    return cachedAccounts.flatMap(accountEntity => {\n      return this.getAccountInfoForTenantProfiles(accountEntity, accountFilter);\n    });\n  }\n  getAccountInfoForTenantProfiles(accountEntity, accountFilter) {\n    return this.getTenantProfilesFromAccountEntity(accountEntity, accountFilter?.tenantId, accountFilter);\n  }\n  getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter) {\n    let tenantedAccountInfo = null;\n    let idTokenClaims;\n    if (tenantProfileFilter) {\n      if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {\n        return null;\n      }\n    }\n    const idToken = this.getIdToken(accountInfo, tokenKeys, tenantProfile.tenantId);\n    if (idToken) {\n      idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\n      if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {\n        // ID token sourced claims don't match so this tenant profile is not a match\n        return null;\n      }\n    }\n    // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims\n    tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims);\n    return tenantedAccountInfo;\n  }\n  getTenantProfilesFromAccountEntity(accountEntity, targetTenantId, tenantProfileFilter) {\n    const accountInfo = accountEntity.getAccountInfo();\n    let searchTenantProfiles = accountInfo.tenantProfiles || new Map();\n    const tokenKeys = this.getTokenKeys();\n    // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists\n    if (targetTenantId) {\n      const tenantProfile = searchTenantProfiles.get(targetTenantId);\n      if (tenantProfile) {\n        // Reduce search field to just this tenant profile\n        searchTenantProfiles = new Map([[targetTenantId, tenantProfile]]);\n      } else {\n        // No tenant profile for search tenant ID, return empty array\n        return [];\n      }\n    }\n    const matchingTenantProfiles = [];\n    searchTenantProfiles.forEach(tenantProfile => {\n      const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter);\n      if (tenantedAccountInfo) {\n        matchingTenantProfiles.push(tenantedAccountInfo);\n      }\n    });\n    return matchingTenantProfiles;\n  }\n  tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {\n    if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {\n      return false;\n    }\n    if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {\n      return false;\n    }\n    if (tenantProfileFilter.isHomeTenant !== undefined && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {\n      return false;\n    }\n    return true;\n  }\n  idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {\n    // Tenant Profile filtering\n    if (tenantProfileFilter) {\n      if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n  async saveCacheRecord(cacheRecord, storeInCache) {\n    if (!cacheRecord) {\n      throw createClientAuthError(invalidCacheRecord);\n    }\n    if (!!cacheRecord.account) {\n      this.setAccount(cacheRecord.account);\n    }\n    if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n      this.setIdTokenCredential(cacheRecord.idToken);\n    }\n    if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n      await this.saveAccessToken(cacheRecord.accessToken);\n    }\n    if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {\n      this.setRefreshTokenCredential(cacheRecord.refreshToken);\n    }\n    if (!!cacheRecord.appMetadata) {\n      this.setAppMetadata(cacheRecord.appMetadata);\n    }\n  }\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n  async saveAccessToken(credential) {\n    const accessTokenFilter = {\n      clientId: credential.clientId,\n      credentialType: credential.credentialType,\n      environment: credential.environment,\n      homeAccountId: credential.homeAccountId,\n      realm: credential.realm,\n      tokenType: credential.tokenType,\n      requestedClaimsHash: credential.requestedClaimsHash\n    };\n    const tokenKeys = this.getTokenKeys();\n    const currentScopes = ScopeSet.fromString(credential.target);\n    const removedAccessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n        return;\n      }\n      const tokenEntity = this.getAccessTokenCredential(key);\n      if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n        const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n        if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n          removedAccessTokens.push(this.removeAccessToken(key));\n        }\n      }\n    });\n    await Promise.all(removedAccessTokens);\n    this.setAccessTokenCredential(credential);\n  }\n  /**\r\n   * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache\r\n   * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param accountFilter - An object containing Account properties to filter by\r\n   */\n  getAccountsFilteredBy(accountFilter) {\n    const allAccountKeys = this.getAccountKeys();\n    const matchingAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n      const entity = this.getAccount(cacheKey, this.commonLogger);\n      // Match base account fields\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {\n        return;\n      }\n      // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts\n      const tenantProfileFilter = {\n        localAccountId: accountFilter?.localAccountId,\n        name: accountFilter?.name\n      };\n      const matchingTenantProfiles = entity.tenantProfiles?.filter(tenantProfile => {\n        return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);\n      });\n      if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {\n        // No tenant profile for this account matches filter, don't add to list of matching accounts\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  }\n  /**\r\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n   * @param key\r\n   * @param homeAccountId\r\n   * @param tenantId\r\n   * @returns\r\n   */\n  isAccountKey(key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    }\n    // Do not check environment as aliasing can cause false negatives\n    return true;\n  }\n  /**\r\n   * Returns true if the given key matches our credential key schema.\r\n   * @param key\r\n   */\n  isCredentialKey(key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    const lowerCaseKey = key.toLowerCase();\n    // Credential keys must indicate what credential type they represent\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n      const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Returns whether or not the given credential entity matches the filter\r\n   * @param entity\r\n   * @param filter\r\n   * @returns\r\n   */\n  credentialMatchesFilter(entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\r\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\r\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n  getAppMetadataFilteredBy(filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  }\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  getAppMetadataFilteredByInternal(environment, clientId) {\n    const allCacheKeys = this.getKeys();\n    const matchingAppMetadata = {};\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-appMetadata type cache entities\n      if (!this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  }\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n  getAuthorityMetadataByAlias(host) {\n    const allCacheKeys = this.getAuthorityMetadataKeys();\n    let matchedEntity = null;\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  }\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n  async removeAllAccounts() {\n    const allAccountKeys = this.getAccountKeys();\n    const removedAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      removedAccounts.push(this.removeAccount(cacheKey));\n    });\n    await Promise.all(removedAccounts);\n  }\n  /**\r\n   * Removes the account and related tokens for a given account key\r\n   * @param account\r\n   */\n  async removeAccount(accountKey) {\n    const account = this.getAccount(accountKey, this.commonLogger);\n    if (!account) {\n      return;\n    }\n    await this.removeAccountContext(account);\n    this.removeItem(accountKey);\n  }\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  async removeAccountContext(account) {\n    const allTokenKeys = this.getTokenKeys();\n    const accountId = account.generateAccountId();\n    const removedCredentials = [];\n    allTokenKeys.idToken.forEach(key => {\n      if (key.indexOf(accountId) === 0) {\n        this.removeIdToken(key);\n      }\n    });\n    allTokenKeys.accessToken.forEach(key => {\n      if (key.indexOf(accountId) === 0) {\n        removedCredentials.push(this.removeAccessToken(key));\n      }\n    });\n    allTokenKeys.refreshToken.forEach(key => {\n      if (key.indexOf(accountId) === 0) {\n        this.removeRefreshToken(key);\n      }\n    });\n    await Promise.all(removedCredentials);\n  }\n  /**\r\n   * Migrates a single-tenant account and all it's associated alternate cross-tenant account objects in the\r\n   * cache into a condensed multi-tenant account object with tenant profiles.\r\n   * @param accountKey\r\n   * @param accountEntity\r\n   * @param logger\r\n   * @returns\r\n   */\n  updateOutdatedCachedAccount(accountKey, accountEntity, logger) {\n    // Only update if account entity is defined and has no tenantProfiles object (is outdated)\n    if (accountEntity && accountEntity.isSingleTenant()) {\n      this.commonLogger?.verbose(\"updateOutdatedCachedAccount: Found a single-tenant (outdated) account entity in the cache, migrating to multi-tenant account entity\");\n      // Get keys of all accounts belonging to user\n      const matchingAccountKeys = this.getAccountKeys().filter(key => {\n        return key.startsWith(accountEntity.homeAccountId);\n      });\n      // Get all account entities belonging to user\n      const accountsToMerge = [];\n      matchingAccountKeys.forEach(key => {\n        const account = this.getCachedAccountEntity(key);\n        if (account) {\n          accountsToMerge.push(account);\n        }\n      });\n      // Set base account to home account if available, any account if not\n      const baseAccount = accountsToMerge.find(account => {\n        return tenantIdMatchesHomeTenant(account.realm, account.homeAccountId);\n      }) || accountsToMerge[0];\n      // Populate tenant profiles built from each account entity belonging to the user\n      baseAccount.tenantProfiles = accountsToMerge.map(account => {\n        return {\n          tenantId: account.realm,\n          localAccountId: account.localAccountId,\n          name: account.name,\n          isHomeTenant: tenantIdMatchesHomeTenant(account.realm, account.homeAccountId)\n        };\n      });\n      const updatedAccount = CacheManager.toObject(new AccountEntity(), {\n        ...baseAccount\n      });\n      const newAccountKey = updatedAccount.generateAccountKey();\n      // Clear cache of legacy account objects that have been collpsed into tenant profiles\n      matchingAccountKeys.forEach(key => {\n        if (key !== newAccountKey) {\n          this.removeOutdatedAccount(accountKey);\n        }\n      });\n      // Cache updated account object\n      this.setAccount(updatedAccount);\n      logger?.verbose(\"Updated an outdated account entity in the cache\");\n      return updatedAccount;\n    }\n    // No update is necessary\n    return accountEntity;\n  }\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n  async removeAccessToken(key) {\n    const credential = this.getAccessTokenCredential(key);\n    if (!credential) {\n      return;\n    }\n    // Remove Token Binding Key from key store for PoP Tokens Credentials\n    if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n      if (credential.tokenType === AuthenticationScheme.POP) {\n        const accessTokenWithAuthSchemeEntity = credential;\n        const kid = accessTokenWithAuthSchemeEntity.keyId;\n        if (kid) {\n          try {\n            await this.cryptoImpl.removeTokenBindingKey(kid);\n          } catch (error) {\n            throw createClientAuthError(bindingKeyNotRemoved);\n          }\n        }\n      }\n    }\n    return this.removeItem(key);\n  }\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n  removeAppMetadata() {\n    const allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(cacheKey => {\n      if (this.isAppMetadata(cacheKey)) {\n        this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  }\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n  readAccountFromCache(account) {\n    const accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey, this.commonLogger);\n  }\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param account {AccountInfo}\r\n   * @param tokenKeys {?TokenKeys}\r\n   * @param targetRealm {?string}\r\n   * @param performanceClient {?IPerformanceClient}\r\n   * @param correlationId {?string}\r\n   */\n  getIdToken(account, tokenKeys, targetRealm, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    const idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: targetRealm\n    };\n    const idTokenMap = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    const numIdTokens = idTokenMap.size;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      let tokensToBeRemoved = idTokenMap;\n      // Multiple tenant profiles and no tenant specified, pick home account\n      if (!targetRealm) {\n        const homeIdTokenMap = new Map();\n        idTokenMap.forEach((idToken, key) => {\n          if (idToken.realm === account.tenantId) {\n            homeIdTokenMap.set(key, idToken);\n          }\n        });\n        const numHomeIdTokens = homeIdTokenMap.size;\n        if (numHomeIdTokens < 1) {\n          this.commonLogger.info(\"CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result\");\n          return idTokenMap.values().next().value;\n        } else if (numHomeIdTokens === 1) {\n          this.commonLogger.info(\"CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile\");\n          return homeIdTokenMap.values().next().value;\n        } else {\n          // Multiple ID tokens for home tenant profile, remove all and return null\n          tokensToBeRemoved = homeIdTokenMap;\n        }\n      }\n      // Multiple tokens for a single tenant profile, remove all and return null\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple matching ID tokens found, clearing them\");\n      tokensToBeRemoved.forEach((idToken, key) => {\n        this.removeIdToken(key);\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedID: idTokenMap.size\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning ID token\");\n    return idTokenMap.values().next().value;\n  }\n  /**\r\n   * Gets all idTokens matching the given filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  getIdTokensByFilter(filter, tokenKeys) {\n    const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    const idTokens = new Map();\n    idTokenKeys.forEach(key => {\n      if (!this.idTokenKeyMatchesFilter(key, {\n        clientId: this.clientId,\n        ...filter\n      })) {\n        return;\n      }\n      const idToken = this.getIdTokenCredential(key);\n      if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.set(key, idToken);\n      }\n    });\n    return idTokens;\n  }\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @returns\r\n   */\n  idTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Removes idToken from the cache\r\n   * @param key\r\n   */\n  removeIdToken(key) {\n    this.removeItem(key);\n  }\n  /**\r\n   * Removes refresh token from the cache\r\n   * @param key\r\n   */\n  removeRefreshToken(key) {\n    this.removeItem(key);\n  }\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param account {AccountInfo}\r\n   * @param request {BaseAuthRequest}\r\n   * @param tokenKeys {?TokenKeys}\r\n   * @param performanceClient {?IPerformanceClient}\r\n   * @param correlationId {?string}\r\n   */\n  getAccessToken(account, request, tokenKeys, targetRealm, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    const scopes = ScopeSet.createSearchScopes(request.scopes);\n    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    const accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: targetRealm || account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    const accessTokens = [];\n    accessTokenKeys.forEach(key => {\n      // Validate key\n      if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        const accessToken = this.getAccessTokenCredential(key);\n        // Validate value\n        if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    const numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n      accessTokens.forEach(accessToken => {\n        void this.removeAccessToken(generateCredentialKey(accessToken));\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedAT: accessTokens.length\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  }\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @param keyMustContainAllScopes\r\n   * @returns\r\n   */\n  accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      const scopes = filter.target.asArray();\n      for (let i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  }\n  /**\r\n   * Gets all access tokens matching the filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  getAccessTokensByFilter(filter) {\n    const tokenKeys = this.getTokenKeys();\n    const accessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      const accessToken = this.getAccessTokenCredential(key);\n      if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  }\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param account {AccountInfo}\r\n   * @param familyRT {boolean}\r\n   * @param tokenKeys {?TokenKeys}\r\n   * @param performanceClient {?IPerformanceClient}\r\n   * @param correlationId {?string}\r\n   */\n  getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    const id = familyRT ? THE_FAMILY_ID : undefined;\n    const refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    const refreshTokens = [];\n    refreshTokenKeys.forEach(key => {\n      // Validate key\n      if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        const refreshToken = this.getRefreshTokenCredential(key);\n        // Validate value\n        if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    const numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    if (numRefreshTokens > 1 && performanceClient && correlationId) {\n      performanceClient.addFields({\n        multiMatchedRT: numRefreshTokens\n      }, correlationId);\n    }\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  }\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   */\n  refreshTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n  readAppMetadataFromCache(environment) {\n    const appMetadataFilter = {\n      environment,\n      clientId: this.clientId\n    };\n    const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    const appMetadataEntries = Object.keys(appMetadata).map(key => appMetadata[key]);\n    const numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw createClientAuthError(multipleMatchingAppMetadata);\n    }\n    return appMetadataEntries[0];\n  }\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  isAppMetadataFOCI(environment) {\n    const appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  }\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n  matchHomeAccountId(entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  }\n  /**\r\n   * helper to match account ids\r\n   * @param entity\r\n   * @param localAccountId\r\n   * @returns\r\n   */\n  matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {\n    const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;\n    return localAccountId === idTokenLocalAccountId;\n  }\n  matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {\n    return tenantProfile.localAccountId === localAccountId;\n  }\n  /**\r\n   * helper to match names\r\n   * @param entity\r\n   * @param name\r\n   * @returns true if the downcased name properties are present and match in the filter and the entity\r\n   */\n  matchName(claims, name) {\n    return !!(name.toLowerCase() === claims.name?.toLowerCase());\n  }\n  /**\r\n   * helper to match usernames\r\n   * @param entity\r\n   * @param username\r\n   * @returns\r\n   */\n  matchUsername(cachedUsername, filterUsername) {\n    return !!(cachedUsername && typeof cachedUsername === \"string\" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());\n  }\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n  matchUserAssertionHash(entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  }\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n  matchEnvironment(entity, environment) {\n    // Check static authority options first for cases where authority metadata has not been resolved and cached yet\n    if (this.staticAuthorityOptions) {\n      const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);\n      if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {\n        return true;\n      }\n    }\n    // Query metadata cache if no static authority configuration has aliases that match enviroment\n    const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n  matchCredentialType(entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  }\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n  matchClientId(entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  }\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n  matchFamilyId(entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  }\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n  matchRealm(entity, realm) {\n    return !!(entity.realm?.toLowerCase() === realm.toLowerCase());\n  }\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n  matchNativeAccountId(entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  }\n  /**\r\n   * helper to match loginHint which can be either:\r\n   * 1. login_hint ID token claim\r\n   * 2. username in cached account object\r\n   * 3. upn in ID token claims\r\n   * @param entity\r\n   * @param loginHint\r\n   * @returns\r\n   */\n  matchLoginHintFromTokenClaims(tokenClaims, loginHint) {\n    if (tokenClaims.login_hint === loginHint) {\n      return true;\n    }\n    if (tokenClaims.preferred_username === loginHint) {\n      return true;\n    }\n    if (tokenClaims.upn === loginHint) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Helper to match sid\r\n   * @param entity\r\n   * @param sid\r\n   * @returns true if the sid claim is present and matches the filter\r\n   */\n  matchSid(idTokenClaims, sid) {\n    return idTokenClaims.sid === sid;\n  }\n  matchAuthorityType(entity, authorityType) {\n    return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());\n  }\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n  matchTarget(entity, target) {\n    const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    const entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  }\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  matchTokenType(entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  }\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  matchKeyId(entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  }\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n  isAppMetadata(key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  }\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n  isAuthorityMetadata(key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  }\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n  generateAuthorityMetadataCacheKey(authority) {\n    return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n  }\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n  static toObject(obj, json) {\n    for (const propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  }\n}\n/** @internal */\nclass DefaultStorageClass extends CacheManager {\n  setAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getCachedAccountEntity() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadataKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  removeItem() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  containsKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccountKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getTokenKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  async clear() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  updateCredentialCacheKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  removeOutdatedAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n}\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"names":["CacheManager","constructor","clientId","cryptoImpl","logger","staticAuthorityOptions","commonLogger","clone","name","version","getAllAccounts","accountFilter","buildTenantProfiles","getAccountsFilteredBy","getAccountInfoFilteredBy","allAccounts","length","sortedAccounts","sort","account","idTokenClaims","getBaseAccountInfo","accountEntities","getAccountInfo","cachedAccounts","flatMap","accountEntity","getAccountInfoForTenantProfiles","getTenantProfilesFromAccountEntity","tenantId","getTenantedAccountInfoByFilter","accountInfo","tokenKeys","tenantProfile","tenantProfileFilter","tenantedAccountInfo","tenantProfileMatchesFilter","idToken","getIdToken","extractTokenClaims","secret","base64Decode","idTokenClaimsMatchTenantProfileFilter","updateAccountTenantProfileData","targetTenantId","searchTenantProfiles","tenantProfiles","Map","getTokenKeys","get","matchingTenantProfiles","forEach","push","localAccountId","matchLocalAccountIdFromTenantProfile","isHomeTenant","undefined","matchLocalAccountIdFromTokenClaims","loginHint","matchLoginHintFromTokenClaims","username","matchUsername","preferred_username","matchName","sid","matchSid","saveCacheRecord","cacheRecord","storeInCache","createClientAuthError","invalidCacheRecord","setAccount","setIdTokenCredential","accessToken","saveAccessToken","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","accessTokenFilter","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","currentScopes","ScopeSet","fromString","target","removedAccessTokens","key","accessTokenKeyMatchesFilter","tokenEntity","getAccessTokenCredential","credentialMatchesFilter","tokenScopeSet","intersectingScopeSets","removeAccessToken","Promise","all","setAccessTokenCredential","allAccountKeys","getAccountKeys","matchingAccounts","cacheKey","isAccountKey","entity","getAccount","matchHomeAccountId","matchEnvironment","matchRealm","nativeAccountId","matchNativeAccountId","authorityType","matchAuthorityType","filter","split","Separators","CACHE_KEY_SEPARATOR","toLowerCase","includes","isCredentialKey","lowerCaseKey","indexOf","CredentialType","ID_TOKEN","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","clientIdValidation","familyIdValidation","THE_FAMILY_ID","matchClientId","userAssertionHash","matchUserAssertionHash","matchCredentialType","familyId","matchFamilyId","matchTarget","matchTokenType","AuthenticationScheme","SSH","keyId","matchKeyId","getAppMetadataFilteredBy","getAppMetadataFilteredByInternal","allCacheKeys","getKeys","matchingAppMetadata","isAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","getAuthorityMetadata","aliases","removeAllAccounts","removedAccounts","removeAccount","accountKey","removeAccountContext","removeItem","allTokenKeys","accountId","generateAccountId","removedCredentials","removeIdToken","removeRefreshToken","updateOutdatedCachedAccount","isSingleTenant","verbose","matchingAccountKeys","startsWith","accountsToMerge","getCachedAccountEntity","baseAccount","find","tenantIdMatchesHomeTenant","map","updatedAccount","toObject","AccountEntity","newAccountKey","generateAccountKey","removeOutdatedAccount","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","error","bindingKeyNotRemoved","removeAppMetadata","readAccountFromCache","generateAccountCacheKey","targetRealm","performanceClient","correlationId","trace","idTokenFilter","idTokenMap","getIdTokensByFilter","numIdTokens","size","info","tokensToBeRemoved","homeIdTokenMap","set","numHomeIdTokens","values","next","value","addFields","multiMatchedID","idTokenKeys","idTokens","idTokenKeyMatchesFilter","getIdTokenCredential","inputKey","getAccessToken","request","scopes","createSearchScopes","authScheme","authenticationScheme","BEARER","sshKid","accessTokenKeys","accessTokens","numAccessTokens","generateCredentialKey","multiMatchedAT","keyMustContainAllScopes","asArray","i","getAccessTokensByFilter","getRefreshToken","familyRT","id","refreshTokenFilter","refreshTokenKeys","refreshTokens","refreshTokenKeyMatchesFilter","getRefreshTokenCredential","numRefreshTokens","multiMatchedRT","readAppMetadataFromCache","appMetadataFilter","appMetadataEntries","Object","keys","numAppMetadata","multipleMatchingAppMetadata","isAppMetadataFOCI","tokenClaims","idTokenLocalAccountId","oid","sub","claims","cachedUsername","filterUsername","staticAliases","getAliasesFromStaticSources","cloudMetadata","login_hint","upn","isNotAccessTokenCredential","entityScopeSet","containsScopeSet","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","CACHE_KEY","generateAuthorityMetadataCacheKey","authority","obj","json","propertyName","DefaultStorageClass","methodNotImplemented","setServerTelemetry","getServerTelemetry","setAuthorityMetadata","setThrottlingCache","getThrottlingCache","containsKey","clear","updateCredentialCacheKey"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-common\\src\\cache\\CacheManager.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AccountFilter,\r\n    CredentialFilter,\r\n    ValidCredentialType,\r\n    AppMetadataFilter,\r\n    AppMetadataCache,\r\n    TokenKeys,\r\n    TenantProfileFilter,\r\n} from \"./utils/CacheTypes\";\r\nimport { CacheRecord } from \"./entities/CacheRecord\";\r\nimport {\r\n    CredentialType,\r\n    APP_METADATA,\r\n    THE_FAMILY_ID,\r\n    AUTHORITY_METADATA_CONSTANTS,\r\n    AuthenticationScheme,\r\n    Separators,\r\n} from \"../utils/Constants\";\r\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\r\nimport { generateCredentialKey } from \"./utils/CacheHelpers\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AccountEntity } from \"./entities/AccountEntity\";\r\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\r\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\r\nimport { ICacheManager } from \"./interface/ICacheManager\";\r\nimport {\r\n    createClientAuthError,\r\n    ClientAuthErrorCodes,\r\n} from \"../error/ClientAuthError\";\r\nimport {\r\n    AccountInfo,\r\n    TenantProfile,\r\n    tenantIdMatchesHomeTenant,\r\n    updateAccountTenantProfileData,\r\n} from \"../account/AccountInfo\";\r\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\r\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\r\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\r\nimport { extractTokenClaims } from \"../account/AuthToken\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { name, version } from \"../packageMetadata\";\r\nimport { StoreInCache } from \"../request/StoreInCache\";\r\nimport { getAliasesFromStaticSources } from \"../authority/AuthorityMetadata\";\r\nimport { StaticAuthorityOptions } from \"../authority/AuthorityOptions\";\r\nimport { TokenClaims } from \"../account/TokenClaims\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\n\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n * @internal\r\n */\r\nexport abstract class CacheManager implements ICacheManager {\r\n    protected clientId: string;\r\n    protected cryptoImpl: ICrypto;\r\n    // Instance of logger for functions defined in the msal-common layer\r\n    private commonLogger: Logger;\r\n    private staticAuthorityOptions?: StaticAuthorityOptions;\r\n\r\n    constructor(\r\n        clientId: string,\r\n        cryptoImpl: ICrypto,\r\n        logger: Logger,\r\n        staticAuthorityOptions?: StaticAuthorityOptions\r\n    ) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n        this.commonLogger = logger.clone(name, version);\r\n        this.staticAuthorityOptions = staticAuthorityOptions;\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     *  @param accountKey\r\n     */\r\n    abstract getAccount(\r\n        accountKey: string,\r\n        logger?: Logger\r\n    ): AccountEntity | null;\r\n\r\n    /**\r\n     * Returns deserialized account if found in the cache, otherwiser returns null\r\n     */\r\n    abstract getCachedAccountEntity(accountKey: string): AccountEntity | null;\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param account\r\n     */\r\n    abstract setAccount(account: AccountEntity): void;\r\n\r\n    /**\r\n     * remove account entity from the platform cache if it's outdated\r\n     */\r\n    abstract removeOutdatedAccount(accountKey: string): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param idTokenKey\r\n     */\r\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param idToken\r\n     */\r\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param accessTokenKey\r\n     */\r\n    abstract getAccessTokenCredential(\r\n        accessTokenKey: string\r\n    ): AccessTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param accessToken\r\n     */\r\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param refreshTokenKey\r\n     */\r\n    abstract getRefreshTokenCredential(\r\n        refreshTokenKey: string\r\n    ): RefreshTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    abstract getServerTelemetry(\r\n        serverTelemetryKey: string\r\n    ): ServerTelemetryEntity | null;\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    abstract setServerTelemetry(\r\n        serverTelemetryKey: string,\r\n        serverTelemetry: ServerTelemetryEntity\r\n    ): void;\r\n\r\n    /**\r\n     * fetch cloud discovery metadata entity from the platform cache\r\n     * @param key\r\n     */\r\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\r\n\r\n    /**\r\n     *\r\n     */\r\n    abstract getAuthorityMetadataKeys(): Array<string>;\r\n\r\n    /**\r\n     * set cloud discovery metadata entity to the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    abstract setAuthorityMetadata(\r\n        key: string,\r\n        value: AuthorityMetadataEntity\r\n    ): void;\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    abstract getThrottlingCache(\r\n        throttlingCacheKey: string\r\n    ): ThrottlingEntity | null;\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    abstract setThrottlingCache(\r\n        throttlingCacheKey: string,\r\n        throttlingCache: ThrottlingEntity\r\n    ): void;\r\n\r\n    /**\r\n     * Function to remove an item from cache given its key.\r\n     * @param key\r\n     */\r\n    abstract removeItem(key: string): void;\r\n\r\n    /**\r\n     * Function which returns boolean whether cache contains a specific key.\r\n     * @param key\r\n     */\r\n    abstract containsKey(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which retrieves all current keys from the cache.\r\n     */\r\n    abstract getKeys(): string[];\r\n\r\n    /**\r\n     * Function which retrieves all account keys from the cache\r\n     */\r\n    abstract getAccountKeys(): string[];\r\n\r\n    /**\r\n     * Function which retrieves all token keys from the cache\r\n     */\r\n    abstract getTokenKeys(): TokenKeys;\r\n\r\n    /**\r\n     * Function which clears cache.\r\n     */\r\n    abstract clear(): Promise<void>;\r\n\r\n    /**\r\n     * Function which updates an outdated credential cache key\r\n     */\r\n    abstract updateCredentialCacheKey(\r\n        currentCacheKey: string,\r\n        credential: ValidCredentialType\r\n    ): string;\r\n\r\n    /**\r\n     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\r\n     * @param accountFilter - (Optional) filter to narrow down the accounts returned\r\n     * @returns Array of AccountInfo objects in cache\r\n     */\r\n    getAllAccounts(accountFilter?: AccountFilter): AccountInfo[] {\r\n        return this.buildTenantProfiles(\r\n            this.getAccountsFilteredBy(accountFilter || {}),\r\n            accountFilter\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets first tenanted AccountInfo object found based on provided filters\r\n     */\r\n    getAccountInfoFilteredBy(accountFilter: AccountFilter): AccountInfo | null {\r\n        const allAccounts = this.getAllAccounts(accountFilter);\r\n        if (allAccounts.length > 1) {\r\n            // If one or more accounts are found, prioritize accounts that have an ID token\r\n            const sortedAccounts = allAccounts.sort((account) => {\r\n                return account.idTokenClaims ? -1 : 1;\r\n            });\r\n            return sortedAccounts[0];\r\n        } else if (allAccounts.length === 1) {\r\n            // If only one account is found, return it regardless of whether a matching ID token was found\r\n            return allAccounts[0];\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a single matching\r\n     * @param accountFilter\r\n     * @returns\r\n     */\r\n    getBaseAccountInfo(accountFilter: AccountFilter): AccountInfo | null {\r\n        const accountEntities = this.getAccountsFilteredBy(accountFilter);\r\n        if (accountEntities.length > 0) {\r\n            return accountEntities[0].getAccountInfo();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters\r\n     * and builds the account info objects from the matching ID token's claims\r\n     * @param cachedAccounts\r\n     * @param accountFilter\r\n     * @returns Array of AccountInfo objects that match account and tenant profile filters\r\n     */\r\n    private buildTenantProfiles(\r\n        cachedAccounts: AccountEntity[],\r\n        accountFilter?: AccountFilter\r\n    ): AccountInfo[] {\r\n        return cachedAccounts.flatMap((accountEntity) => {\r\n            return this.getAccountInfoForTenantProfiles(\r\n                accountEntity,\r\n                accountFilter\r\n            );\r\n        });\r\n    }\r\n\r\n    private getAccountInfoForTenantProfiles(\r\n        accountEntity: AccountEntity,\r\n        accountFilter?: AccountFilter\r\n    ): AccountInfo[] {\r\n        return this.getTenantProfilesFromAccountEntity(\r\n            accountEntity,\r\n            accountFilter?.tenantId,\r\n            accountFilter\r\n        );\r\n    }\r\n\r\n    private getTenantedAccountInfoByFilter(\r\n        accountInfo: AccountInfo,\r\n        tokenKeys: TokenKeys,\r\n        tenantProfile: TenantProfile,\r\n        tenantProfileFilter?: TenantProfileFilter\r\n    ): AccountInfo | null {\r\n        let tenantedAccountInfo: AccountInfo | null = null;\r\n        let idTokenClaims: TokenClaims | undefined;\r\n\r\n        if (tenantProfileFilter) {\r\n            if (\r\n                !this.tenantProfileMatchesFilter(\r\n                    tenantProfile,\r\n                    tenantProfileFilter\r\n                )\r\n            ) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const idToken = this.getIdToken(\r\n            accountInfo,\r\n            tokenKeys,\r\n            tenantProfile.tenantId\r\n        );\r\n\r\n        if (idToken) {\r\n            idTokenClaims = extractTokenClaims(\r\n                idToken.secret,\r\n                this.cryptoImpl.base64Decode\r\n            );\r\n\r\n            if (\r\n                !this.idTokenClaimsMatchTenantProfileFilter(\r\n                    idTokenClaims,\r\n                    tenantProfileFilter\r\n                )\r\n            ) {\r\n                // ID token sourced claims don't match so this tenant profile is not a match\r\n                return null;\r\n            }\r\n        }\r\n\r\n        // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims\r\n        tenantedAccountInfo = updateAccountTenantProfileData(\r\n            accountInfo,\r\n            tenantProfile,\r\n            idTokenClaims\r\n        );\r\n\r\n        return tenantedAccountInfo;\r\n    }\r\n\r\n    private getTenantProfilesFromAccountEntity(\r\n        accountEntity: AccountEntity,\r\n        targetTenantId?: string,\r\n        tenantProfileFilter?: TenantProfileFilter\r\n    ): AccountInfo[] {\r\n        const accountInfo = accountEntity.getAccountInfo();\r\n        let searchTenantProfiles: Map<string, TenantProfile> =\r\n            accountInfo.tenantProfiles || new Map<string, TenantProfile>();\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists\r\n        if (targetTenantId) {\r\n            const tenantProfile = searchTenantProfiles.get(targetTenantId);\r\n            if (tenantProfile) {\r\n                // Reduce search field to just this tenant profile\r\n                searchTenantProfiles = new Map<string, TenantProfile>([\r\n                    [targetTenantId, tenantProfile],\r\n                ]);\r\n            } else {\r\n                // No tenant profile for search tenant ID, return empty array\r\n                return [];\r\n            }\r\n        }\r\n\r\n        const matchingTenantProfiles: AccountInfo[] = [];\r\n        searchTenantProfiles.forEach((tenantProfile: TenantProfile) => {\r\n            const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(\r\n                accountInfo,\r\n                tokenKeys,\r\n                tenantProfile,\r\n                tenantProfileFilter\r\n            );\r\n            if (tenantedAccountInfo) {\r\n                matchingTenantProfiles.push(tenantedAccountInfo);\r\n            }\r\n        });\r\n\r\n        return matchingTenantProfiles;\r\n    }\r\n\r\n    private tenantProfileMatchesFilter(\r\n        tenantProfile: TenantProfile,\r\n        tenantProfileFilter: TenantProfileFilter\r\n    ): boolean {\r\n        if (\r\n            !!tenantProfileFilter.localAccountId &&\r\n            !this.matchLocalAccountIdFromTenantProfile(\r\n                tenantProfile,\r\n                tenantProfileFilter.localAccountId\r\n            )\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            !!tenantProfileFilter.name &&\r\n            !(tenantProfile.name === tenantProfileFilter.name)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            tenantProfileFilter.isHomeTenant !== undefined &&\r\n            !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private idTokenClaimsMatchTenantProfileFilter(\r\n        idTokenClaims: TokenClaims,\r\n        tenantProfileFilter?: TenantProfileFilter\r\n    ): boolean {\r\n        // Tenant Profile filtering\r\n        if (tenantProfileFilter) {\r\n            if (\r\n                !!tenantProfileFilter.localAccountId &&\r\n                !this.matchLocalAccountIdFromTokenClaims(\r\n                    idTokenClaims,\r\n                    tenantProfileFilter.localAccountId\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (\r\n                !!tenantProfileFilter.loginHint &&\r\n                !this.matchLoginHintFromTokenClaims(\r\n                    idTokenClaims,\r\n                    tenantProfileFilter.loginHint\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (\r\n                !!tenantProfileFilter.username &&\r\n                !this.matchUsername(\r\n                    idTokenClaims.preferred_username,\r\n                    tenantProfileFilter.username\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (\r\n                !!tenantProfileFilter.name &&\r\n                !this.matchName(idTokenClaims, tenantProfileFilter.name)\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (\r\n                !!tenantProfileFilter.sid &&\r\n                !this.matchSid(idTokenClaims, tenantProfileFilter.sid)\r\n            ) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    async saveCacheRecord(\r\n        cacheRecord: CacheRecord,\r\n        storeInCache?: StoreInCache\r\n    ): Promise<void> {\r\n        if (!cacheRecord) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.invalidCacheRecord\r\n            );\r\n        }\r\n\r\n        if (!!cacheRecord.account) {\r\n            this.setAccount(cacheRecord.account);\r\n        }\r\n\r\n        if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\r\n            this.setIdTokenCredential(cacheRecord.idToken);\r\n        }\r\n\r\n        if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\r\n            await this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n\r\n        if (\r\n            !!cacheRecord.refreshToken &&\r\n            storeInCache?.refreshToken !== false\r\n        ) {\r\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n        }\r\n\r\n        if (!!cacheRecord.appMetadata) {\r\n            this.setAppMetadata(cacheRecord.appMetadata);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    private async saveAccessToken(\r\n        credential: AccessTokenEntity\r\n    ): Promise<void> {\r\n        const accessTokenFilter: CredentialFilter = {\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n            tokenType: credential.tokenType,\r\n            requestedClaimsHash: credential.requestedClaimsHash,\r\n        };\r\n\r\n        const tokenKeys = this.getTokenKeys();\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n\r\n        const removedAccessTokens: Array<Promise<void>> = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if (\r\n                !this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            const tokenEntity = this.getAccessTokenCredential(key);\r\n\r\n            if (\r\n                tokenEntity &&\r\n                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)\r\n            ) {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    removedAccessTokens.push(this.removeAccessToken(key));\r\n                }\r\n            }\r\n        });\r\n        await Promise.all(removedAccessTokens);\r\n        this.setAccessTokenCredential(credential);\r\n    }\r\n\r\n    /**\r\n     * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache\r\n     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param accountFilter - An object containing Account properties to filter by\r\n     */\r\n    getAccountsFilteredBy(accountFilter: AccountFilter): AccountEntity[] {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const matchingAccounts: AccountEntity[] = [];\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {\r\n                // Don't parse value if the key doesn't match the account filters\r\n                return;\r\n            }\r\n\r\n            const entity: AccountEntity | null = this.getAccount(\r\n                cacheKey,\r\n                this.commonLogger\r\n            );\r\n\r\n            // Match base account fields\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                !!accountFilter.homeAccountId &&\r\n                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                !!accountFilter.username &&\r\n                !this.matchUsername(entity.username, accountFilter.username)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                !!accountFilter.environment &&\r\n                !this.matchEnvironment(entity, accountFilter.environment)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                !!accountFilter.realm &&\r\n                !this.matchRealm(entity, accountFilter.realm)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                !!accountFilter.nativeAccountId &&\r\n                !this.matchNativeAccountId(\r\n                    entity,\r\n                    accountFilter.nativeAccountId\r\n                )\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                !!accountFilter.authorityType &&\r\n                !this.matchAuthorityType(entity, accountFilter.authorityType)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts\r\n            const tenantProfileFilter: TenantProfileFilter = {\r\n                localAccountId: accountFilter?.localAccountId,\r\n                name: accountFilter?.name,\r\n            };\r\n\r\n            const matchingTenantProfiles = entity.tenantProfiles?.filter(\r\n                (tenantProfile: TenantProfile) => {\r\n                    return this.tenantProfileMatchesFilter(\r\n                        tenantProfile,\r\n                        tenantProfileFilter\r\n                    );\r\n                }\r\n            );\r\n\r\n            if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {\r\n                // No tenant profile for this account matches filter, don't add to list of matching accounts\r\n                return;\r\n            }\r\n\r\n            matchingAccounts.push(entity);\r\n        });\r\n\r\n        return matchingAccounts;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n     * @param key\r\n     * @param homeAccountId\r\n     * @param tenantId\r\n     * @returns\r\n     */\r\n    isAccountKey(\r\n        key: string,\r\n        homeAccountId?: string,\r\n        tenantId?: string\r\n    ): boolean {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\r\n            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            homeAccountId &&\r\n            !key.toLowerCase().includes(homeAccountId.toLowerCase())\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        // Do not check environment as aliasing can cause false negatives\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key matches our credential key schema.\r\n     * @param key\r\n     */\r\n    isCredentialKey(key: string): boolean {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\r\n            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\r\n            return false;\r\n        }\r\n\r\n        const lowerCaseKey = key.toLowerCase();\r\n        // Credential keys must indicate what credential type they represent\r\n        if (\r\n            lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) ===\r\n                -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) ===\r\n                -1 &&\r\n            lowerCaseKey.indexOf(\r\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()\r\n            ) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) ===\r\n                -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) >\r\n            -1\r\n        ) {\r\n            // Refresh tokens must contain the client id or family id\r\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            if (\r\n                lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 &&\r\n                lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1\r\n            ) {\r\n                return false;\r\n            }\r\n        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\r\n            // Tokens must contain the clientId\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the given credential entity matches the filter\r\n     * @param entity\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    credentialMatchesFilter(\r\n        entity: ValidCredentialType,\r\n        filter: CredentialFilter\r\n    ): boolean {\r\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            !!filter.userAssertionHash &&\r\n            !this.matchUserAssertionHash(entity, filter.userAssertionHash)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n         */\r\n        if (\r\n            typeof filter.homeAccountId === \"string\" &&\r\n            !this.matchHomeAccountId(entity, filter.homeAccountId)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            !!filter.environment &&\r\n            !this.matchEnvironment(entity, filter.environment)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            !!filter.credentialType &&\r\n            !this.matchCredentialType(entity, filter.credentialType)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n         */\r\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\r\n            return false;\r\n        }\r\n\r\n        // If request OR cached entity has requested Claims Hash, check if they match\r\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\r\n            // Don't match if either is undefined or they are different\r\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Access Token with Auth Scheme specific matching\r\n        if (\r\n            entity.credentialType ===\r\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\r\n        ) {\r\n            if (\r\n                !!filter.tokenType &&\r\n                !this.matchTokenType(entity, filter.tokenType)\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\r\n            if (filter.tokenType === AuthenticationScheme.SSH) {\r\n                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\r\n        return this.getAppMetadataFilteredByInternal(\r\n            filter.environment,\r\n            filter.clientId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    private getAppMetadataFilteredByInternal(\r\n        environment?: string,\r\n        clientId?: string\r\n    ): AppMetadataCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAppMetadata: AppMetadataCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAppMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAppMetadata[cacheKey] = entity;\r\n        });\r\n\r\n        return matchingAppMetadata;\r\n    }\r\n\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\r\n        const allCacheKeys = this.getAuthorityMetadataKeys();\r\n        let matchedEntity = null;\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (\r\n                !this.isAuthorityMetadata(cacheKey) ||\r\n                cacheKey.indexOf(this.clientId) === -1\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAuthorityMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n\r\n            matchedEntity = entity;\r\n        });\r\n\r\n        return matchedEntity;\r\n    }\r\n\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    async removeAllAccounts(): Promise<void> {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const removedAccounts: Array<Promise<void>> = [];\r\n\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            removedAccounts.push(this.removeAccount(cacheKey));\r\n        });\r\n\r\n        await Promise.all(removedAccounts);\r\n    }\r\n\r\n    /**\r\n     * Removes the account and related tokens for a given account key\r\n     * @param account\r\n     */\r\n    async removeAccount(accountKey: string): Promise<void> {\r\n        const account = this.getAccount(accountKey, this.commonLogger);\r\n        if (!account) {\r\n            return;\r\n        }\r\n        await this.removeAccountContext(account);\r\n        this.removeItem(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    async removeAccountContext(account: AccountEntity): Promise<void> {\r\n        const allTokenKeys = this.getTokenKeys();\r\n        const accountId = account.generateAccountId();\r\n        const removedCredentials: Array<Promise<void>> = [];\r\n\r\n        allTokenKeys.idToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeIdToken(key);\r\n            }\r\n        });\r\n\r\n        allTokenKeys.accessToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                removedCredentials.push(this.removeAccessToken(key));\r\n            }\r\n        });\r\n\r\n        allTokenKeys.refreshToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeRefreshToken(key);\r\n            }\r\n        });\r\n\r\n        await Promise.all(removedCredentials);\r\n    }\r\n\r\n    /**\r\n     * Migrates a single-tenant account and all it's associated alternate cross-tenant account objects in the\r\n     * cache into a condensed multi-tenant account object with tenant profiles.\r\n     * @param accountKey\r\n     * @param accountEntity\r\n     * @param logger\r\n     * @returns\r\n     */\r\n    protected updateOutdatedCachedAccount(\r\n        accountKey: string,\r\n        accountEntity: AccountEntity | null,\r\n        logger?: Logger\r\n    ): AccountEntity | null {\r\n        // Only update if account entity is defined and has no tenantProfiles object (is outdated)\r\n        if (accountEntity && accountEntity.isSingleTenant()) {\r\n            this.commonLogger?.verbose(\r\n                \"updateOutdatedCachedAccount: Found a single-tenant (outdated) account entity in the cache, migrating to multi-tenant account entity\"\r\n            );\r\n\r\n            // Get keys of all accounts belonging to user\r\n            const matchingAccountKeys = this.getAccountKeys().filter(\r\n                (key: string) => {\r\n                    return key.startsWith(accountEntity.homeAccountId);\r\n                }\r\n            );\r\n\r\n            // Get all account entities belonging to user\r\n            const accountsToMerge: AccountEntity[] = [];\r\n            matchingAccountKeys.forEach((key: string) => {\r\n                const account = this.getCachedAccountEntity(key);\r\n                if (account) {\r\n                    accountsToMerge.push(account);\r\n                }\r\n            });\r\n\r\n            // Set base account to home account if available, any account if not\r\n            const baseAccount =\r\n                accountsToMerge.find((account) => {\r\n                    return tenantIdMatchesHomeTenant(\r\n                        account.realm,\r\n                        account.homeAccountId\r\n                    );\r\n                }) || accountsToMerge[0];\r\n\r\n            // Populate tenant profiles built from each account entity belonging to the user\r\n            baseAccount.tenantProfiles = accountsToMerge.map(\r\n                (account: AccountEntity) => {\r\n                    return {\r\n                        tenantId: account.realm,\r\n                        localAccountId: account.localAccountId,\r\n                        name: account.name,\r\n                        isHomeTenant: tenantIdMatchesHomeTenant(\r\n                            account.realm,\r\n                            account.homeAccountId\r\n                        ),\r\n                    };\r\n                }\r\n            );\r\n\r\n            const updatedAccount = CacheManager.toObject(new AccountEntity(), {\r\n                ...baseAccount,\r\n            });\r\n\r\n            const newAccountKey = updatedAccount.generateAccountKey();\r\n\r\n            // Clear cache of legacy account objects that have been collpsed into tenant profiles\r\n            matchingAccountKeys.forEach((key: string) => {\r\n                if (key !== newAccountKey) {\r\n                    this.removeOutdatedAccount(accountKey);\r\n                }\r\n            });\r\n\r\n            // Cache updated account object\r\n            this.setAccount(updatedAccount);\r\n            logger?.verbose(\"Updated an outdated account entity in the cache\");\r\n            return updatedAccount;\r\n        }\r\n\r\n        // No update is necessary\r\n        return accountEntity;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    async removeAccessToken(key: string): Promise<void> {\r\n        const credential = this.getAccessTokenCredential(key);\r\n        if (!credential) {\r\n            return;\r\n        }\r\n\r\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\r\n        if (\r\n            credential.credentialType.toLowerCase() ===\r\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()\r\n        ) {\r\n            if (credential.tokenType === AuthenticationScheme.POP) {\r\n                const accessTokenWithAuthSchemeEntity =\r\n                    credential as AccessTokenEntity;\r\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\r\n\r\n                if (kid) {\r\n                    try {\r\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\r\n                    } catch (error) {\r\n                        throw createClientAuthError(\r\n                            ClientAuthErrorCodes.bindingKeyNotRemoved\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    removeAppMetadata(): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            if (this.isAppMetadata(cacheKey)) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\r\n        const accountKey: string =\r\n            AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey, this.commonLogger);\r\n    }\r\n\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param account {AccountInfo}\r\n     * @param tokenKeys {?TokenKeys}\r\n     * @param targetRealm {?string}\r\n     * @param performanceClient {?IPerformanceClient}\r\n     * @param correlationId {?string}\r\n     */\r\n    getIdToken(\r\n        account: AccountInfo,\r\n        tokenKeys?: TokenKeys,\r\n        targetRealm?: string,\r\n        performanceClient?: IPerformanceClient,\r\n        correlationId?: string\r\n    ): IdTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\r\n        const idTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.clientId,\r\n            realm: targetRealm,\r\n        };\r\n\r\n        const idTokenMap: Map<string, IdTokenEntity> = this.getIdTokensByFilter(\r\n            idTokenFilter,\r\n            tokenKeys\r\n        );\r\n\r\n        const numIdTokens = idTokenMap.size;\r\n\r\n        if (numIdTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\r\n            return null;\r\n        } else if (numIdTokens > 1) {\r\n            let tokensToBeRemoved: Map<string, IdTokenEntity> = idTokenMap;\r\n            // Multiple tenant profiles and no tenant specified, pick home account\r\n            if (!targetRealm) {\r\n                const homeIdTokenMap: Map<string, IdTokenEntity> = new Map<\r\n                    string,\r\n                    IdTokenEntity\r\n                >();\r\n                idTokenMap.forEach((idToken, key) => {\r\n                    if (idToken.realm === account.tenantId) {\r\n                        homeIdTokenMap.set(key, idToken);\r\n                    }\r\n                });\r\n                const numHomeIdTokens = homeIdTokenMap.size;\r\n                if (numHomeIdTokens < 1) {\r\n                    this.commonLogger.info(\r\n                        \"CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result\"\r\n                    );\r\n                    return idTokenMap.values().next().value;\r\n                } else if (numHomeIdTokens === 1) {\r\n                    this.commonLogger.info(\r\n                        \"CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile\"\r\n                    );\r\n                    return homeIdTokenMap.values().next().value;\r\n                } else {\r\n                    // Multiple ID tokens for home tenant profile, remove all and return null\r\n                    tokensToBeRemoved = homeIdTokenMap;\r\n                }\r\n            }\r\n            // Multiple tokens for a single tenant profile, remove all and return null\r\n            this.commonLogger.info(\r\n                \"CacheManager:getIdToken - Multiple matching ID tokens found, clearing them\"\r\n            );\r\n            tokensToBeRemoved.forEach((idToken, key) => {\r\n                this.removeIdToken(key);\r\n            });\r\n            if (performanceClient && correlationId) {\r\n                performanceClient.addFields(\r\n                    { multiMatchedID: idTokenMap.size },\r\n                    correlationId\r\n                );\r\n            }\r\n            return null;\r\n        }\r\n\r\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning ID token\");\r\n        return idTokenMap.values().next().value;\r\n    }\r\n\r\n    /**\r\n     * Gets all idTokens matching the given filter\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    getIdTokensByFilter(\r\n        filter: CredentialFilter,\r\n        tokenKeys?: TokenKeys\r\n    ): Map<string, IdTokenEntity> {\r\n        const idTokenKeys =\r\n            (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;\r\n\r\n        const idTokens: Map<string, IdTokenEntity> = new Map<\r\n            string,\r\n            IdTokenEntity\r\n        >();\r\n        idTokenKeys.forEach((key) => {\r\n            if (\r\n                !this.idTokenKeyMatchesFilter(key, {\r\n                    clientId: this.clientId,\r\n                    ...filter,\r\n                })\r\n            ) {\r\n                return;\r\n            }\r\n            const idToken = this.getIdTokenCredential(key);\r\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\r\n                idTokens.set(key, idToken);\r\n            }\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    idTokenKeyMatchesFilter(\r\n        inputKey: string,\r\n        filter: CredentialFilter\r\n    ): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (\r\n            filter.clientId &&\r\n            key.indexOf(filter.clientId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            filter.homeAccountId &&\r\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes idToken from the cache\r\n     * @param key\r\n     */\r\n    removeIdToken(key: string): void {\r\n        this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes refresh token from the cache\r\n     * @param key\r\n     */\r\n    removeRefreshToken(key: string): void {\r\n        this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param account {AccountInfo}\r\n     * @param request {BaseAuthRequest}\r\n     * @param tokenKeys {?TokenKeys}\r\n     * @param performanceClient {?IPerformanceClient}\r\n     * @param correlationId {?string}\r\n     */\r\n    getAccessToken(\r\n        account: AccountInfo,\r\n        request: BaseAuthRequest,\r\n        tokenKeys?: TokenKeys,\r\n        targetRealm?: string,\r\n        performanceClient?: IPerformanceClient,\r\n        correlationId?: string\r\n    ): AccessTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getAccessToken called\");\r\n        const scopes = ScopeSet.createSearchScopes(request.scopes);\r\n        const authScheme =\r\n            request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        const credentialType =\r\n            authScheme &&\r\n            authScheme.toLowerCase() !==\r\n                AuthenticationScheme.BEARER.toLowerCase()\r\n                ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\r\n                : CredentialType.ACCESS_TOKEN;\r\n\r\n        const accessTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId: this.clientId,\r\n            realm: targetRealm || account.tenantId,\r\n            target: scopes,\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n        };\r\n\r\n        const accessTokenKeys =\r\n            (tokenKeys && tokenKeys.accessToken) ||\r\n            this.getTokenKeys().accessToken;\r\n        const accessTokens: AccessTokenEntity[] = [];\r\n\r\n        accessTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (\r\n                this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)\r\n            ) {\r\n                const accessToken = this.getAccessTokenCredential(key);\r\n\r\n                // Validate value\r\n                if (\r\n                    accessToken &&\r\n                    this.credentialMatchesFilter(accessToken, accessTokenFilter)\r\n                ) {\r\n                    accessTokens.push(accessToken);\r\n                }\r\n            }\r\n        });\r\n\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            this.commonLogger.info(\r\n                \"CacheManager:getAccessToken - No token found\"\r\n            );\r\n            return null;\r\n        } else if (numAccessTokens > 1) {\r\n            this.commonLogger.info(\r\n                \"CacheManager:getAccessToken - Multiple access tokens found, clearing them\"\r\n            );\r\n            accessTokens.forEach((accessToken) => {\r\n                void this.removeAccessToken(generateCredentialKey(accessToken));\r\n            });\r\n            if (performanceClient && correlationId) {\r\n                performanceClient.addFields(\r\n                    { multiMatchedAT: accessTokens.length },\r\n                    correlationId\r\n                );\r\n            }\r\n            return null;\r\n        }\r\n\r\n        this.commonLogger.info(\r\n            \"CacheManager:getAccessToken - Returning access token\"\r\n        );\r\n        return accessTokens[0];\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     * @param keyMustContainAllScopes\r\n     * @returns\r\n     */\r\n    accessTokenKeyMatchesFilter(\r\n        inputKey: string,\r\n        filter: CredentialFilter,\r\n        keyMustContainAllScopes: boolean\r\n    ): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (\r\n            filter.clientId &&\r\n            key.indexOf(filter.clientId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            filter.homeAccountId &&\r\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            filter.requestedClaimsHash &&\r\n            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.target) {\r\n            const scopes = filter.target.asArray();\r\n            for (let i = 0; i < scopes.length; i++) {\r\n                if (\r\n                    keyMustContainAllScopes &&\r\n                    !key.includes(scopes[i].toLowerCase())\r\n                ) {\r\n                    // When performing a cache lookup a missing scope would be a cache miss\r\n                    return false;\r\n                } else if (\r\n                    !keyMustContainAllScopes &&\r\n                    key.includes(scopes[i].toLowerCase())\r\n                ) {\r\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets all access tokens matching the filter\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    getAccessTokensByFilter(filter: CredentialFilter): AccessTokenEntity[] {\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        const accessTokens: AccessTokenEntity[] = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\r\n                return;\r\n            }\r\n\r\n            const accessToken = this.getAccessTokenCredential(key);\r\n            if (\r\n                accessToken &&\r\n                this.credentialMatchesFilter(accessToken, filter)\r\n            ) {\r\n                accessTokens.push(accessToken);\r\n            }\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param account {AccountInfo}\r\n     * @param familyRT {boolean}\r\n     * @param tokenKeys {?TokenKeys}\r\n     * @param performanceClient {?IPerformanceClient}\r\n     * @param correlationId {?string}\r\n     */\r\n    getRefreshToken(\r\n        account: AccountInfo,\r\n        familyRT: boolean,\r\n        tokenKeys?: TokenKeys,\r\n        performanceClient?: IPerformanceClient,\r\n        correlationId?: string\r\n    ): RefreshTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\r\n        const id = familyRT ? THE_FAMILY_ID : undefined;\r\n        const refreshTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: this.clientId,\r\n            familyId: id,\r\n        };\r\n\r\n        const refreshTokenKeys =\r\n            (tokenKeys && tokenKeys.refreshToken) ||\r\n            this.getTokenKeys().refreshToken;\r\n        const refreshTokens: RefreshTokenEntity[] = [];\r\n\r\n        refreshTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\r\n                const refreshToken = this.getRefreshTokenCredential(key);\r\n                // Validate value\r\n                if (\r\n                    refreshToken &&\r\n                    this.credentialMatchesFilter(\r\n                        refreshToken,\r\n                        refreshTokenFilter\r\n                    )\r\n                ) {\r\n                    refreshTokens.push(refreshToken);\r\n                }\r\n            }\r\n        });\r\n\r\n        const numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            this.commonLogger.info(\r\n                \"CacheManager:getRefreshToken - No refresh token found.\"\r\n            );\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n\r\n        if (numRefreshTokens > 1 && performanceClient && correlationId) {\r\n            performanceClient.addFields(\r\n                { multiMatchedRT: numRefreshTokens },\r\n                correlationId\r\n            );\r\n        }\r\n\r\n        this.commonLogger.info(\r\n            \"CacheManager:getRefreshToken - returning refresh token\"\r\n        );\r\n        return refreshTokens[0] as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     */\r\n    refreshTokenKeyMatchesFilter(\r\n        inputKey: string,\r\n        filter: CredentialFilter\r\n    ): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (\r\n            filter.familyId &&\r\n            key.indexOf(filter.familyId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        // If familyId is used, clientId is not in the key\r\n        if (\r\n            !filter.familyId &&\r\n            filter.clientId &&\r\n            key.indexOf(filter.clientId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            filter.homeAccountId &&\r\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    readAppMetadataFromCache(environment: string): AppMetadataEntity | null {\r\n        const appMetadataFilter: AppMetadataFilter = {\r\n            environment,\r\n            clientId: this.clientId,\r\n        };\r\n\r\n        const appMetadata: AppMetadataCache =\r\n            this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(\r\n            appMetadata\r\n        ).map((key) => appMetadata[key]);\r\n\r\n        const numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        } else if (numAppMetadata > 1) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.multipleMatchingAppMetadata\r\n            );\r\n        }\r\n\r\n        return appMetadataEntries[0] as AppMetadataEntity;\r\n    }\r\n\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    isAppMetadataFOCI(environment: string): boolean {\r\n        const appMetadata = this.readAppMetadataFromCache(environment);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    private matchHomeAccountId(\r\n        entity: AccountEntity | CredentialEntity,\r\n        homeAccountId: string\r\n    ): boolean {\r\n        return !!(\r\n            typeof entity.homeAccountId === \"string\" &&\r\n            homeAccountId === entity.homeAccountId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param entity\r\n     * @param localAccountId\r\n     * @returns\r\n     */\r\n    private matchLocalAccountIdFromTokenClaims(\r\n        tokenClaims: TokenClaims,\r\n        localAccountId: string\r\n    ): boolean {\r\n        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;\r\n        return localAccountId === idTokenLocalAccountId;\r\n    }\r\n\r\n    private matchLocalAccountIdFromTenantProfile(\r\n        tenantProfile: TenantProfile,\r\n        localAccountId: string\r\n    ): boolean {\r\n        return tenantProfile.localAccountId === localAccountId;\r\n    }\r\n\r\n    /**\r\n     * helper to match names\r\n     * @param entity\r\n     * @param name\r\n     * @returns true if the downcased name properties are present and match in the filter and the entity\r\n     */\r\n    private matchName(claims: TokenClaims, name: string): boolean {\r\n        return !!(name.toLowerCase() === claims.name?.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * helper to match usernames\r\n     * @param entity\r\n     * @param username\r\n     * @returns\r\n     */\r\n    private matchUsername(\r\n        cachedUsername?: string,\r\n        filterUsername?: string\r\n    ): boolean {\r\n        return !!(\r\n            cachedUsername &&\r\n            typeof cachedUsername === \"string\" &&\r\n            filterUsername?.toLowerCase() === cachedUsername.toLowerCase()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    private matchUserAssertionHash(\r\n        entity: CredentialEntity,\r\n        userAssertionHash: string\r\n    ): boolean {\r\n        return !!(\r\n            entity.userAssertionHash &&\r\n            userAssertionHash === entity.userAssertionHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    private matchEnvironment(\r\n        entity: AccountEntity | CredentialEntity | AppMetadataEntity,\r\n        environment: string\r\n    ): boolean {\r\n        // Check static authority options first for cases where authority metadata has not been resolved and cached yet\r\n        if (this.staticAuthorityOptions) {\r\n            const staticAliases = getAliasesFromStaticSources(\r\n                this.staticAuthorityOptions,\r\n                this.commonLogger\r\n            );\r\n            if (\r\n                staticAliases.includes(environment) &&\r\n                staticAliases.includes(entity.environment)\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Query metadata cache if no static authority configuration has aliases that match enviroment\r\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (\r\n            cloudMetadata &&\r\n            cloudMetadata.aliases.indexOf(entity.environment) > -1\r\n        ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    private matchCredentialType(\r\n        entity: CredentialEntity,\r\n        credentialType: string\r\n    ): boolean {\r\n        return (\r\n            entity.credentialType &&\r\n            credentialType.toLowerCase() === entity.credentialType.toLowerCase()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    private matchClientId(\r\n        entity: CredentialEntity | AppMetadataEntity,\r\n        clientId: string\r\n    ): boolean {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    }\r\n\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    private matchFamilyId(\r\n        entity: CredentialEntity | AppMetadataEntity,\r\n        familyId: string\r\n    ): boolean {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    }\r\n\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    private matchRealm(\r\n        entity: AccountEntity | CredentialEntity,\r\n        realm: string\r\n    ): boolean {\r\n        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * helper to match nativeAccountId\r\n     * @param entity\r\n     * @param nativeAccountId\r\n     * @returns boolean indicating the match result\r\n     */\r\n    private matchNativeAccountId(\r\n        entity: AccountEntity,\r\n        nativeAccountId: string\r\n    ): boolean {\r\n        return !!(\r\n            entity.nativeAccountId && nativeAccountId === entity.nativeAccountId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * helper to match loginHint which can be either:\r\n     * 1. login_hint ID token claim\r\n     * 2. username in cached account object\r\n     * 3. upn in ID token claims\r\n     * @param entity\r\n     * @param loginHint\r\n     * @returns\r\n     */\r\n    private matchLoginHintFromTokenClaims(\r\n        tokenClaims: TokenClaims,\r\n        loginHint: string\r\n    ): boolean {\r\n        if (tokenClaims.login_hint === loginHint) {\r\n            return true;\r\n        }\r\n\r\n        if (tokenClaims.preferred_username === loginHint) {\r\n            return true;\r\n        }\r\n\r\n        if (tokenClaims.upn === loginHint) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Helper to match sid\r\n     * @param entity\r\n     * @param sid\r\n     * @returns true if the sid claim is present and matches the filter\r\n     */\r\n    private matchSid(idTokenClaims: TokenClaims, sid: string): boolean {\r\n        return idTokenClaims.sid === sid;\r\n    }\r\n\r\n    private matchAuthorityType(\r\n        entity: AccountEntity,\r\n        authorityType: string\r\n    ): boolean {\r\n        return !!(\r\n            entity.authorityType &&\r\n            authorityType.toLowerCase() === entity.authorityType.toLowerCase()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    private matchTarget(entity: CredentialEntity, target: ScopeSet): boolean {\r\n        const isNotAccessTokenCredential =\r\n            entity.credentialType !== CredentialType.ACCESS_TOKEN &&\r\n            entity.credentialType !==\r\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\r\n\r\n        if (isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n\r\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\r\n\r\n        return entityScopeSet.containsScopeSet(target);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchTokenType(\r\n        entity: CredentialEntity,\r\n        tokenType: AuthenticationScheme\r\n    ): boolean {\r\n        return !!(entity.tokenType && entity.tokenType === tokenType);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\r\n        return !!(entity.keyId && entity.keyId === keyId);\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    private isAppMetadata(key: string): boolean {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    protected isAuthorityMetadata(key: string): boolean {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    generateAuthorityMetadataCacheKey(authority: string): string {\r\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\r\n    }\r\n\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject<T>(obj: T, json: object): T {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class DefaultStorageClass extends CacheManager {\r\n    setAccount(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getAccount(): AccountEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getCachedAccountEntity(): AccountEntity | null {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setIdTokenCredential(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getIdTokenCredential(): IdTokenEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setAccessTokenCredential(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getAccessTokenCredential(): AccessTokenEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setRefreshTokenCredential(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getRefreshTokenCredential(): RefreshTokenEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setAppMetadata(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getAppMetadata(): AppMetadataEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setServerTelemetry(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getServerTelemetry(): ServerTelemetryEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setAuthorityMetadata(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    setThrottlingCache(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getThrottlingCache(): ThrottlingEntity {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    removeItem(): boolean {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    containsKey(): boolean {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getKeys(): string[] {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getAccountKeys(): string[] {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    getTokenKeys(): TokenKeys {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    async clear(): Promise<void> {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    updateCredentialCacheKey(): string {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n    removeOutdatedAccount(): void {\r\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}