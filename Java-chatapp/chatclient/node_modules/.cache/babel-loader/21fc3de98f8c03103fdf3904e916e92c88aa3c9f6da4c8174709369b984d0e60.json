{"ast":null,"code":"/*! @azure/msal-common v14.6.0 2024-01-09 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { TimeUtils } from '../utils/TimeUtils.mjs';\nimport { RefreshTokenClient } from './RefreshTokenClient.mjs';\nimport { ClientAuthError, createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { CacheOutcome } from '../utils/Constants.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { getTenantFromAuthorityString } from '../authority/Authority.mjs';\nimport { tokenRefreshRequired, noAccountInSilentRequest, authTimeNotFound } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/** @internal */\nclass SilentFlowClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n  }\n  /**\r\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n   * the given token and returns the renewed token\r\n   * @param request\r\n   */\n  async acquireToken(request) {\n    try {\n      const [authResponse, cacheOutcome] = await this.acquireCachedToken(request);\n      // if the token is not expired but must be refreshed; get a new one in the background\n      if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\n        this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.\");\n        // refresh the access token in the background\n        const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\n        refreshTokenClient.acquireTokenByRefreshToken(request).catch(() => {\n          // do nothing, this is running in the background and no action is to be taken upon success or failure\n        });\n      }\n      // return the cached token\n      return authResponse;\n    } catch (e) {\n      if (e instanceof ClientAuthError && e.errorCode === tokenRefreshRequired) {\n        const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\n        return refreshTokenClient.acquireTokenByRefreshToken(request);\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n  async acquireCachedToken(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);\n    let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;\n    if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {\n      // Must refresh due to present force_refresh flag.\n      this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);\n      throw createClientAuthError(tokenRefreshRequired);\n    }\n    // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n    if (!request.account) {\n      throw createClientAuthError(noAccountInSilentRequest);\n    }\n    const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);\n    const tokenKeys = this.cacheManager.getTokenKeys();\n    const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId, this.performanceClient, request.correlationId);\n    if (!cachedAccessToken) {\n      // must refresh due to non-existent access_token\n      this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);\n      throw createClientAuthError(tokenRefreshRequired);\n    } else if (TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) || TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n      // must refresh due to the expires_in value\n      this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);\n      throw createClientAuthError(tokenRefreshRequired);\n    } else if (cachedAccessToken.refreshOn && TimeUtils.isTokenExpired(cachedAccessToken.refreshOn, 0)) {\n      // must refresh (in the background) due to the refresh_in value\n      lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;\n      // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead\n    }\n    const environment = request.authority || this.authority.getPreferredCache();\n    const cacheRecord = {\n      account: this.cacheManager.readAccountFromCache(request.account),\n      accessToken: cachedAccessToken,\n      idToken: this.cacheManager.getIdToken(request.account, tokenKeys, requestTenantId, this.performanceClient, request.correlationId),\n      refreshToken: null,\n      appMetadata: this.cacheManager.readAppMetadataFromCache(environment)\n    };\n    this.setCacheOutcome(lastCacheOutcome, request.correlationId);\n    if (this.config.serverTelemetryManager) {\n      this.config.serverTelemetryManager.incrementCacheHits();\n    }\n    return [await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request), lastCacheOutcome];\n  }\n  setCacheOutcome(cacheOutcome, correlationId) {\n    this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);\n    this.performanceClient?.addFields({\n      cacheOutcome: cacheOutcome\n    }, correlationId);\n    if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {\n      this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);\n    }\n  }\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n  async generateResultFromCacheRecord(cacheRecord, request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);\n    let idTokenClaims;\n    if (cacheRecord.idToken) {\n      idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);\n    }\n    // token max_age check\n    if (request.maxAge || request.maxAge === 0) {\n      const authTime = idTokenClaims?.auth_time;\n      if (!authTime) {\n        throw createClientAuthError(authTimeNotFound);\n      }\n      checkMaxAge(authTime, request.maxAge);\n    }\n    return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);\n  }\n}\nexport { SilentFlowClient };","map":{"version":3,"names":["SilentFlowClient","BaseClient","constructor","configuration","performanceClient","acquireToken","request","authResponse","cacheOutcome","acquireCachedToken","CacheOutcome","PROACTIVELY_REFRESHED","logger","info","refreshTokenClient","RefreshTokenClient","config","acquireTokenByRefreshToken","catch","e","ClientAuthError","errorCode","tokenRefreshRequired","addQueueMeasurement","PerformanceEvents","SilentFlowClientAcquireCachedToken","correlationId","lastCacheOutcome","NOT_APPLICABLE","forceRefresh","cacheOptions","claimsBasedCachingEnabled","StringUtils","isEmptyObj","claims","setCacheOutcome","FORCE_REFRESH_OR_CLAIMS","createClientAuthError","account","noAccountInSilentRequest","requestTenantId","tenantId","getTenantFromAuthorityString","authority","tokenKeys","cacheManager","getTokenKeys","cachedAccessToken","getAccessToken","NO_CACHED_ACCESS_TOKEN","TimeUtils","wasClockTurnedBack","cachedAt","isTokenExpired","expiresOn","systemOptions","tokenRenewalOffsetSeconds","CACHED_ACCESS_TOKEN_EXPIRED","refreshOn","environment","getPreferredCache","cacheRecord","readAccountFromCache","accessToken","idToken","getIdToken","refreshToken","appMetadata","readAppMetadataFromCache","serverTelemetryManager","incrementCacheHits","invokeAsync","generateResultFromCacheRecord","bind","SilentFlowClientGenerateResultFromCacheRecord","addFields","idTokenClaims","extractTokenClaims","secret","cryptoInterface","base64Decode","maxAge","authTime","auth_time","authTimeNotFound","checkMaxAge","ResponseHandler","generateAuthenticationResult","cryptoUtils"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-common\\src\\client\\SilentFlowClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\r\nimport {\r\n    ClientAuthError,\r\n    ClientAuthErrorCodes,\r\n    createClientAuthError,\r\n} from \"../error/ClientAuthError\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { CacheOutcome } from \"../utils/Constants\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { checkMaxAge, extractTokenClaims } from \"../account/AuthToken\";\r\nimport { TokenClaims } from \"../account/TokenClaims\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\nimport { invokeAsync } from \"../utils/FunctionWrappers\";\r\nimport { getTenantFromAuthorityString } from \"../authority/Authority\";\r\n\r\n/** @internal */\r\nexport class SilentFlowClient extends BaseClient {\r\n    constructor(\r\n        configuration: ClientConfiguration,\r\n        performanceClient?: IPerformanceClient\r\n    ) {\r\n        super(configuration, performanceClient);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n     * the given token and returns the renewed token\r\n     * @param request\r\n     */\r\n    async acquireToken(\r\n        request: CommonSilentFlowRequest\r\n    ): Promise<AuthenticationResult> {\r\n        try {\r\n            const [authResponse, cacheOutcome] = await this.acquireCachedToken(\r\n                request\r\n            );\r\n\r\n            // if the token is not expired but must be refreshed; get a new one in the background\r\n            if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\r\n                this.logger.info(\r\n                    \"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.\"\r\n                );\r\n\r\n                // refresh the access token in the background\r\n                const refreshTokenClient = new RefreshTokenClient(\r\n                    this.config,\r\n                    this.performanceClient\r\n                );\r\n\r\n                refreshTokenClient\r\n                    .acquireTokenByRefreshToken(request)\r\n                    .catch(() => {\r\n                        // do nothing, this is running in the background and no action is to be taken upon success or failure\r\n                    });\r\n            }\r\n\r\n            // return the cached token\r\n            return authResponse;\r\n        } catch (e) {\r\n            if (\r\n                e instanceof ClientAuthError &&\r\n                e.errorCode === ClientAuthErrorCodes.tokenRefreshRequired\r\n            ) {\r\n                const refreshTokenClient = new RefreshTokenClient(\r\n                    this.config,\r\n                    this.performanceClient\r\n                );\r\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves token from cache or throws an error if it must be refreshed.\r\n     * @param request\r\n     */\r\n    async acquireCachedToken(\r\n        request: CommonSilentFlowRequest\r\n    ): Promise<[AuthenticationResult, CacheOutcome]> {\r\n        this.performanceClient?.addQueueMeasurement(\r\n            PerformanceEvents.SilentFlowClientAcquireCachedToken,\r\n            request.correlationId\r\n        );\r\n        let lastCacheOutcome: CacheOutcome = CacheOutcome.NOT_APPLICABLE;\r\n\r\n        if (\r\n            request.forceRefresh ||\r\n            (!this.config.cacheOptions.claimsBasedCachingEnabled &&\r\n                !StringUtils.isEmptyObj(request.claims))\r\n        ) {\r\n            // Must refresh due to present force_refresh flag.\r\n            this.setCacheOutcome(\r\n                CacheOutcome.FORCE_REFRESH_OR_CLAIMS,\r\n                request.correlationId\r\n            );\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.tokenRefreshRequired\r\n            );\r\n        }\r\n\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.noAccountInSilentRequest\r\n            );\r\n        }\r\n\r\n        const requestTenantId =\r\n            request.account.tenantId ||\r\n            getTenantFromAuthorityString(request.authority);\r\n        const tokenKeys = this.cacheManager.getTokenKeys();\r\n        const cachedAccessToken = this.cacheManager.getAccessToken(\r\n            request.account,\r\n            request,\r\n            tokenKeys,\r\n            requestTenantId,\r\n            this.performanceClient,\r\n            request.correlationId\r\n        );\r\n\r\n        if (!cachedAccessToken) {\r\n            // must refresh due to non-existent access_token\r\n            this.setCacheOutcome(\r\n                CacheOutcome.NO_CACHED_ACCESS_TOKEN,\r\n                request.correlationId\r\n            );\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.tokenRefreshRequired\r\n            );\r\n        } else if (\r\n            TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) ||\r\n            TimeUtils.isTokenExpired(\r\n                cachedAccessToken.expiresOn,\r\n                this.config.systemOptions.tokenRenewalOffsetSeconds\r\n            )\r\n        ) {\r\n            // must refresh due to the expires_in value\r\n            this.setCacheOutcome(\r\n                CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED,\r\n                request.correlationId\r\n            );\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.tokenRefreshRequired\r\n            );\r\n        } else if (\r\n            cachedAccessToken.refreshOn &&\r\n            TimeUtils.isTokenExpired(cachedAccessToken.refreshOn, 0)\r\n        ) {\r\n            // must refresh (in the background) due to the refresh_in value\r\n            lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;\r\n\r\n            // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead\r\n        }\r\n\r\n        const environment =\r\n            request.authority || this.authority.getPreferredCache();\r\n        const cacheRecord: CacheRecord = {\r\n            account: this.cacheManager.readAccountFromCache(request.account),\r\n            accessToken: cachedAccessToken,\r\n            idToken: this.cacheManager.getIdToken(\r\n                request.account,\r\n                tokenKeys,\r\n                requestTenantId,\r\n                this.performanceClient,\r\n                request.correlationId\r\n            ),\r\n            refreshToken: null,\r\n            appMetadata:\r\n                this.cacheManager.readAppMetadataFromCache(environment),\r\n        };\r\n\r\n        this.setCacheOutcome(lastCacheOutcome, request.correlationId);\r\n\r\n        if (this.config.serverTelemetryManager) {\r\n            this.config.serverTelemetryManager.incrementCacheHits();\r\n        }\r\n\r\n        return [\r\n            await invokeAsync(\r\n                this.generateResultFromCacheRecord.bind(this),\r\n                PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,\r\n                this.logger,\r\n                this.performanceClient,\r\n                request.correlationId\r\n            )(cacheRecord, request),\r\n            lastCacheOutcome,\r\n        ];\r\n    }\r\n\r\n    private setCacheOutcome(\r\n        cacheOutcome: CacheOutcome,\r\n        correlationId: string\r\n    ): void {\r\n        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);\r\n        this.performanceClient?.addFields(\r\n            {\r\n                cacheOutcome: cacheOutcome,\r\n            },\r\n            correlationId\r\n        );\r\n        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {\r\n            this.logger.info(\r\n                `Token refresh is required due to cache outcome: ${cacheOutcome}`\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to build response object from the CacheRecord\r\n     * @param cacheRecord\r\n     */\r\n    private async generateResultFromCacheRecord(\r\n        cacheRecord: CacheRecord,\r\n        request: CommonSilentFlowRequest\r\n    ): Promise<AuthenticationResult> {\r\n        this.performanceClient?.addQueueMeasurement(\r\n            PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,\r\n            request.correlationId\r\n        );\r\n        let idTokenClaims: TokenClaims | undefined;\r\n        if (cacheRecord.idToken) {\r\n            idTokenClaims = extractTokenClaims(\r\n                cacheRecord.idToken.secret,\r\n                this.config.cryptoInterface.base64Decode\r\n            );\r\n        }\r\n\r\n        // token max_age check\r\n        if (request.maxAge || request.maxAge === 0) {\r\n            const authTime = idTokenClaims?.auth_time;\r\n            if (!authTime) {\r\n                throw createClientAuthError(\r\n                    ClientAuthErrorCodes.authTimeNotFound\r\n                );\r\n            }\r\n\r\n            checkMaxAge(authTime, request.maxAge);\r\n        }\r\n\r\n        return ResponseHandler.generateAuthenticationResult(\r\n            this.cryptoUtils,\r\n            this.authority,\r\n            cacheRecord,\r\n            true,\r\n            request,\r\n            idTokenClaims\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}