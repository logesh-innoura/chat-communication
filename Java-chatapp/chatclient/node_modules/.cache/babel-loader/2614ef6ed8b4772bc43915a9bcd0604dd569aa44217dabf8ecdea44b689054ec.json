{"ast":null,"code":"/*! @azure/msal-browser v3.7.0 2024-01-09 */\n'use strict';\n\nimport { BrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DatabaseStorage } from './DatabaseStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\r\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\r\n */\nclass AsyncMemoryStorage {\n  constructor(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n  handleDatabaseAccessError(error) {\n    if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  }\n  /**\r\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\r\n   * storage object if item isn't found in-memory.\r\n   * @param key\r\n   */\n  async getItem(key) {\n    const item = this.inMemoryCache.getItem(key);\n    if (!item) {\n      try {\n        this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n        return await this.indexedDBCache.getItem(key);\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return item;\n  }\n  /**\r\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\r\n   * storage object with the given key.\r\n   * @param key\r\n   * @param value\r\n   */\n  async setItem(key, value) {\n    this.inMemoryCache.setItem(key, value);\n    try {\n      await this.indexedDBCache.setItem(key, value);\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n    }\n  }\n  /**\r\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\r\n   * @param key\r\n   */\n  async removeItem(key) {\n    this.inMemoryCache.removeItem(key);\n    try {\n      await this.indexedDBCache.removeItem(key);\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n    }\n  }\n  /**\r\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\r\n   * asynchronous storage object.\r\n   */\n  async getKeys() {\n    const cacheKeys = this.inMemoryCache.getKeys();\n    if (cacheKeys.length === 0) {\n      try {\n        this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n        return await this.indexedDBCache.getKeys();\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return cacheKeys;\n  }\n  /**\r\n   * Returns true or false if the given key is present in the cache.\r\n   * @param key\r\n   */\n  async containsKey(key) {\n    const containsKey = this.inMemoryCache.containsKey(key);\n    if (!containsKey) {\n      try {\n        this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n        return await this.indexedDBCache.containsKey(key);\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return containsKey;\n  }\n  /**\r\n   * Clears in-memory Map\r\n   */\n  clearInMemory() {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n    this.inMemoryCache.clear();\n    this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n  }\n  /**\r\n   * Tries to delete the IndexedDB database\r\n   * @returns\r\n   */\n  async clearPersistent() {\n    try {\n      this.logger.verbose(\"Deleting persistent keystore\");\n      const dbDeleted = await this.indexedDBCache.deleteDatabase();\n      if (dbDeleted) {\n        this.logger.verbose(\"Persistent keystore deleted\");\n      }\n      return dbDeleted;\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n      return false;\n    }\n  }\n}\nexport { AsyncMemoryStorage };","map":{"version":3,"names":["AsyncMemoryStorage","constructor","logger","storeName","inMemoryCache","MemoryStorage","indexedDBCache","DatabaseStorage","handleDatabaseAccessError","error","BrowserAuthError","errorCode","databaseUnavailable","getItem","key","item","verbose","e","setItem","value","removeItem","getKeys","cacheKeys","length","containsKey","clearInMemory","clear","clearPersistent","dbDeleted","deleteDatabase"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-browser\\src\\cache\\AsyncMemoryStorage.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Logger } from \"@azure/msal-common\";\r\nimport {\r\n    BrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../error/BrowserAuthError\";\r\nimport { DatabaseStorage } from \"./DatabaseStorage\";\r\nimport { IAsyncStorage } from \"./IAsyncMemoryStorage\";\r\nimport { MemoryStorage } from \"./MemoryStorage\";\r\n\r\n/**\r\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\r\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\r\n */\r\nexport class AsyncMemoryStorage<T> implements IAsyncStorage<T> {\r\n    private inMemoryCache: MemoryStorage<T>;\r\n    private indexedDBCache: DatabaseStorage<T>;\r\n    private logger: Logger;\r\n    private storeName: string;\r\n\r\n    constructor(logger: Logger, storeName: string) {\r\n        this.inMemoryCache = new MemoryStorage<T>();\r\n        this.indexedDBCache = new DatabaseStorage<T>();\r\n        this.logger = logger;\r\n        this.storeName = storeName;\r\n    }\r\n\r\n    private handleDatabaseAccessError(error: unknown): void {\r\n        if (\r\n            error instanceof BrowserAuthError &&\r\n            error.errorCode === BrowserAuthErrorCodes.databaseUnavailable\r\n        ) {\r\n            this.logger.error(\r\n                \"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\"\r\n            );\r\n        } else {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\r\n     * storage object if item isn't found in-memory.\r\n     * @param key\r\n     */\r\n    async getItem(key: string): Promise<T | null> {\r\n        const item = this.inMemoryCache.getItem(key);\r\n        if (!item) {\r\n            try {\r\n                this.logger.verbose(\r\n                    \"Queried item not found in in-memory cache, now querying persistent storage.\"\r\n                );\r\n                return await this.indexedDBCache.getItem(key);\r\n            } catch (e) {\r\n                this.handleDatabaseAccessError(e);\r\n            }\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\r\n     * storage object with the given key.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    async setItem(key: string, value: T): Promise<void> {\r\n        this.inMemoryCache.setItem(key, value);\r\n        try {\r\n            await this.indexedDBCache.setItem(key, value);\r\n        } catch (e) {\r\n            this.handleDatabaseAccessError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\r\n     * @param key\r\n     */\r\n    async removeItem(key: string): Promise<void> {\r\n        this.inMemoryCache.removeItem(key);\r\n        try {\r\n            await this.indexedDBCache.removeItem(key);\r\n        } catch (e) {\r\n            this.handleDatabaseAccessError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\r\n     * asynchronous storage object.\r\n     */\r\n    async getKeys(): Promise<string[]> {\r\n        const cacheKeys = this.inMemoryCache.getKeys();\r\n        if (cacheKeys.length === 0) {\r\n            try {\r\n                this.logger.verbose(\r\n                    \"In-memory cache is empty, now querying persistent storage.\"\r\n                );\r\n                return await this.indexedDBCache.getKeys();\r\n            } catch (e) {\r\n                this.handleDatabaseAccessError(e);\r\n            }\r\n        }\r\n        return cacheKeys;\r\n    }\r\n\r\n    /**\r\n     * Returns true or false if the given key is present in the cache.\r\n     * @param key\r\n     */\r\n    async containsKey(key: string): Promise<boolean> {\r\n        const containsKey = this.inMemoryCache.containsKey(key);\r\n        if (!containsKey) {\r\n            try {\r\n                this.logger.verbose(\r\n                    \"Key not found in in-memory cache, now querying persistent storage.\"\r\n                );\r\n                return await this.indexedDBCache.containsKey(key);\r\n            } catch (e) {\r\n                this.handleDatabaseAccessError(e);\r\n            }\r\n        }\r\n        return containsKey;\r\n    }\r\n\r\n    /**\r\n     * Clears in-memory Map\r\n     */\r\n    clearInMemory(): void {\r\n        // InMemory cache is a Map instance, clear is straightforward\r\n        this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\r\n        this.inMemoryCache.clear();\r\n        this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\r\n    }\r\n\r\n    /**\r\n     * Tries to delete the IndexedDB database\r\n     * @returns\r\n     */\r\n    async clearPersistent(): Promise<boolean> {\r\n        try {\r\n            this.logger.verbose(\"Deleting persistent keystore\");\r\n            const dbDeleted = await this.indexedDBCache.deleteDatabase();\r\n            if (dbDeleted) {\r\n                this.logger.verbose(\"Persistent keystore deleted\");\r\n            }\r\n\r\n            return dbDeleted;\r\n        } catch (e) {\r\n            this.handleDatabaseAccessError(e);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}