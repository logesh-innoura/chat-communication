{"ast":null,"code":"/*! @azure/msal-browser v3.7.0 2024-01-09 */\n'use strict';\n\nimport { createClientAuthError, ClientAuthErrorCodes, ServerError, invokeAsync, PerformanceEvents } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys, ApiId } from '../utils/BrowserConstants.mjs';\nimport { emptyNavigateUri, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass RedirectHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Redirects window to given URL.\r\n   * @param urlNavigate\r\n   */\n  async initiateAuthRequest(requestUrl, params) {\n    this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n    // Navigate if valid URL\n    if (requestUrl) {\n      // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n      if (params.redirectStartPage) {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\");\n        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, params.redirectStartPage, true);\n      }\n      // Set interaction status in the library.\n      this.browserStorage.setTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, this.authCodeRequest.correlationId, true);\n      this.browserStorage.cacheCodeRequest(this.authCodeRequest);\n      this.logger.infoPii(`RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`);\n      const navigationOptions = {\n        apiId: ApiId.acquireTokenRedirect,\n        timeout: params.redirectTimeout,\n        noHistory: false\n      };\n      // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n      if (typeof params.onRedirectNavigate === \"function\") {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\");\n        const navigate = params.onRedirectNavigate(requestUrl);\n        // Returning false from onRedirectNavigate will stop navigation\n        if (navigate !== false) {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\");\n          await params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n          return;\n        } else {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\");\n          return;\n        }\n      } else {\n        // Navigate window to request URL\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\");\n        await params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n        return;\n      }\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.info(\"RedirectHandler.initiateAuthRequest: Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\r\n   * Handle authorization code response in the window.\r\n   * @param hash\r\n   */\n  async handleCodeResponse(response, state) {\n    this.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n    // Handle code response.\n    const stateKey = this.browserStorage.generateStateKey(state);\n    const requestState = this.browserStorage.getTemporaryCache(stateKey);\n    if (!requestState) {\n      throw createClientAuthError(ClientAuthErrorCodes.stateNotFound, \"Cached State\");\n    }\n    let authCodeResponse;\n    try {\n      authCodeResponse = this.authModule.handleFragmentResponse(response, requestState);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    // Get cached items\n    const nonceKey = this.browserStorage.generateNonceKey(requestState);\n    const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, this.authCodeRequest.correlationId)(authCodeResponse.cloud_instance_host_name, this.authCodeRequest.correlationId);\n    }\n    authCodeResponse.nonce = cachedNonce || undefined;\n    authCodeResponse.state = requestState;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const cachedCcsCred = this.checkCcsCredentials();\n      if (cachedCcsCred) {\n        this.authCodeRequest.ccsCredential = cachedCcsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await this.authModule.acquireToken(this.authCodeRequest, authCodeResponse);\n    this.browserStorage.cleanRequestByState(state);\n    return tokenResponse;\n  }\n  /**\r\n   * Looks up ccs creds in the cache\r\n   */\n  checkCcsCredentials() {\n    // Look up ccs credential in temp cache\n    const cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);\n    if (cachedCcsCred) {\n      try {\n        return JSON.parse(cachedCcsCred);\n      } catch (e) {\n        this.authModule.logger.error(\"Cache credential could not be parsed\");\n        this.authModule.logger.errorPii(`Cache credential could not be parsed: ${cachedCcsCred}`);\n      }\n    }\n    return null;\n  }\n}\nexport { RedirectHandler };","map":{"version":3,"names":["RedirectHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","initiateAuthRequest","requestUrl","params","verbose","redirectStartPage","setTemporaryCache","TemporaryCacheKeys","ORIGIN_URI","CORRELATION_ID","correlationId","cacheCodeRequest","infoPii","navigationOptions","apiId","ApiId","acquireTokenRedirect","timeout","redirectTimeout","noHistory","onRedirectNavigate","navigate","navigationClient","navigateExternal","info","createBrowserAuthError","emptyNavigateUri","handleCodeResponse","response","state","setInteractionInProgress","stateKey","generateStateKey","requestState","getTemporaryCache","createClientAuthError","ClientAuthErrorCodes","stateNotFound","authCodeResponse","handleFragmentResponse","e","ServerError","subError","userCancelled","nonceKey","generateNonceKey","cachedNonce","code","cloud_instance_host_name","invokeAsync","updateAuthority","bind","PerformanceEvents","UpdateTokenEndpointAuthority","nonce","undefined","client_info","clientInfo","cachedCcsCred","checkCcsCredentials","ccsCredential","tokenResponse","acquireToken","cleanRequestByState","CCS_CREDENTIAL","JSON","parse","error","errorPii"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\RedirectHandler.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AuthorizationCodeClient,\r\n    CommonAuthorizationCodeRequest,\r\n    Logger,\r\n    ServerError,\r\n    IPerformanceClient,\r\n    createClientAuthError,\r\n    ClientAuthErrorCodes,\r\n    CcsCredential,\r\n    invokeAsync,\r\n    PerformanceEvents,\r\n    ServerAuthorizationCodeResponse,\r\n} from \"@azure/msal-common\";\r\nimport {\r\n    createBrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../error/BrowserAuthError\";\r\nimport { ApiId, TemporaryCacheKeys } from \"../utils/BrowserConstants\";\r\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\r\nimport { INavigationClient } from \"../navigation/INavigationClient\";\r\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\n\r\nexport type RedirectParams = {\r\n    navigationClient: INavigationClient;\r\n    redirectTimeout: number;\r\n    redirectStartPage: string;\r\n    onRedirectNavigate?: (url: string) => void | boolean;\r\n};\r\n\r\nexport class RedirectHandler {\r\n    authModule: AuthorizationCodeClient;\r\n    browserStorage: BrowserCacheManager;\r\n    authCodeRequest: CommonAuthorizationCodeRequest;\r\n    logger: Logger;\r\n    performanceClient: IPerformanceClient;\r\n\r\n    constructor(\r\n        authCodeModule: AuthorizationCodeClient,\r\n        storageImpl: BrowserCacheManager,\r\n        authCodeRequest: CommonAuthorizationCodeRequest,\r\n        logger: Logger,\r\n        performanceClient: IPerformanceClient\r\n    ) {\r\n        this.authModule = authCodeModule;\r\n        this.browserStorage = storageImpl;\r\n        this.authCodeRequest = authCodeRequest;\r\n        this.logger = logger;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n\r\n    /**\r\n     * Redirects window to given URL.\r\n     * @param urlNavigate\r\n     */\r\n    async initiateAuthRequest(\r\n        requestUrl: string,\r\n        params: RedirectParams\r\n    ): Promise<void> {\r\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\r\n        // Navigate if valid URL\r\n        if (requestUrl) {\r\n            // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\r\n            if (params.redirectStartPage) {\r\n                this.logger.verbose(\r\n                    \"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\"\r\n                );\r\n                this.browserStorage.setTemporaryCache(\r\n                    TemporaryCacheKeys.ORIGIN_URI,\r\n                    params.redirectStartPage,\r\n                    true\r\n                );\r\n            }\r\n\r\n            // Set interaction status in the library.\r\n            this.browserStorage.setTemporaryCache(\r\n                TemporaryCacheKeys.CORRELATION_ID,\r\n                this.authCodeRequest.correlationId,\r\n                true\r\n            );\r\n            this.browserStorage.cacheCodeRequest(this.authCodeRequest);\r\n            this.logger.infoPii(\r\n                `RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`\r\n            );\r\n            const navigationOptions: NavigationOptions = {\r\n                apiId: ApiId.acquireTokenRedirect,\r\n                timeout: params.redirectTimeout,\r\n                noHistory: false,\r\n            };\r\n\r\n            // If onRedirectNavigate is implemented, invoke it and provide requestUrl\r\n            if (typeof params.onRedirectNavigate === \"function\") {\r\n                this.logger.verbose(\r\n                    \"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\"\r\n                );\r\n                const navigate = params.onRedirectNavigate(requestUrl);\r\n\r\n                // Returning false from onRedirectNavigate will stop navigation\r\n                if (navigate !== false) {\r\n                    this.logger.verbose(\r\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\"\r\n                    );\r\n                    await params.navigationClient.navigateExternal(\r\n                        requestUrl,\r\n                        navigationOptions\r\n                    );\r\n                    return;\r\n                } else {\r\n                    this.logger.verbose(\r\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\"\r\n                    );\r\n                    return;\r\n                }\r\n            } else {\r\n                // Navigate window to request URL\r\n                this.logger.verbose(\r\n                    \"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\"\r\n                );\r\n                await params.navigationClient.navigateExternal(\r\n                    requestUrl,\r\n                    navigationOptions\r\n                );\r\n                return;\r\n            }\r\n        } else {\r\n            // Throw error if request URL is empty.\r\n            this.logger.info(\r\n                \"RedirectHandler.initiateAuthRequest: Navigate url is empty\"\r\n            );\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.emptyNavigateUri\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle authorization code response in the window.\r\n     * @param hash\r\n     */\r\n    async handleCodeResponse(\r\n        response: ServerAuthorizationCodeResponse,\r\n        state: string\r\n    ): Promise<AuthenticationResult> {\r\n        this.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\r\n\r\n        // Interaction is completed - remove interaction status.\r\n        this.browserStorage.setInteractionInProgress(false);\r\n\r\n        // Handle code response.\r\n        const stateKey = this.browserStorage.generateStateKey(state);\r\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\r\n        if (!requestState) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.stateNotFound,\r\n                \"Cached State\"\r\n            );\r\n        }\r\n\r\n        let authCodeResponse;\r\n        try {\r\n            authCodeResponse = this.authModule.handleFragmentResponse(\r\n                response,\r\n                requestState\r\n            );\r\n        } catch (e) {\r\n            if (\r\n                e instanceof ServerError &&\r\n                e.subError === BrowserAuthErrorCodes.userCancelled\r\n            ) {\r\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\r\n                throw createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.userCancelled\r\n                );\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        // Get cached items\r\n        const nonceKey = this.browserStorage.generateNonceKey(requestState);\r\n        const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\r\n\r\n        // Assign code to request\r\n        this.authCodeRequest.code = authCodeResponse.code;\r\n\r\n        // Check for new cloud instance\r\n        if (authCodeResponse.cloud_instance_host_name) {\r\n            await invokeAsync(\r\n                this.authModule.updateAuthority.bind(this.authModule),\r\n                PerformanceEvents.UpdateTokenEndpointAuthority,\r\n                this.logger,\r\n                this.performanceClient,\r\n                this.authCodeRequest.correlationId\r\n            )(\r\n                authCodeResponse.cloud_instance_host_name,\r\n                this.authCodeRequest.correlationId\r\n            );\r\n        }\r\n\r\n        authCodeResponse.nonce = cachedNonce || undefined;\r\n        authCodeResponse.state = requestState;\r\n\r\n        // Add CCS parameters if available\r\n        if (authCodeResponse.client_info) {\r\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\r\n        } else {\r\n            const cachedCcsCred = this.checkCcsCredentials();\r\n            if (cachedCcsCred) {\r\n                this.authCodeRequest.ccsCredential = cachedCcsCred;\r\n            }\r\n        }\r\n\r\n        // Acquire token with retrieved code.\r\n        const tokenResponse = (await this.authModule.acquireToken(\r\n            this.authCodeRequest,\r\n            authCodeResponse\r\n        )) as AuthenticationResult;\r\n\r\n        this.browserStorage.cleanRequestByState(state);\r\n        return tokenResponse;\r\n    }\r\n\r\n    /**\r\n     * Looks up ccs creds in the cache\r\n     */\r\n    protected checkCcsCredentials(): CcsCredential | null {\r\n        // Look up ccs credential in temp cache\r\n        const cachedCcsCred = this.browserStorage.getTemporaryCache(\r\n            TemporaryCacheKeys.CCS_CREDENTIAL,\r\n            true\r\n        );\r\n        if (cachedCcsCred) {\r\n            try {\r\n                return JSON.parse(cachedCcsCred) as CcsCredential;\r\n            } catch (e) {\r\n                this.authModule.logger.error(\r\n                    \"Cache credential could not be parsed\"\r\n                );\r\n                this.authModule.logger.errorPii(\r\n                    `Cache credential could not be parsed: ${cachedCcsCred}`\r\n                );\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}