{"ast":null,"code":"/*! @azure/msal-browser v3.7.0 2024-01-09 */\n'use strict';\n\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.mjs';\nimport { PerformanceEvents, createAuthError, AuthErrorCodes, AuthenticationScheme } from '@azure/msal-common';\nimport { createNativeAuthError } from '../../error/NativeAuthError.mjs';\nimport { createBrowserAuthError } from '../../error/BrowserAuthError.mjs';\nimport { createNewGuid } from '../../crypto/BrowserCrypto.mjs';\nimport { nativeHandshakeTimeout, nativeExtensionNotInstalled } from '../../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass NativeMessageHandler {\n  constructor(logger, handshakeTimeoutMs, performanceClient, extensionId) {\n    this.logger = logger;\n    this.handshakeTimeoutMs = handshakeTimeoutMs;\n    this.extensionId = extensionId;\n    this.resolvers = new Map(); // Used for non-handshake messages\n    this.handshakeResolvers = new Map(); // Used for handshake messages\n    this.messageChannel = new MessageChannel();\n    this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n    this.performanceClient = performanceClient;\n    this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);\n  }\n  /**\r\n   * Sends a given message to the extension and resolves with the extension response\r\n   * @param body\r\n   */\n  async sendMessage(body) {\n    this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n    const req = {\n      channel: NativeConstants.CHANNEL_ID,\n      extensionId: this.extensionId,\n      responseId: createNewGuid(),\n      body: body\n    };\n    this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n    this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);\n    this.messageChannel.port1.postMessage(req);\n    return new Promise((resolve, reject) => {\n      this.resolvers.set(req.responseId, {\n        resolve,\n        reject\n      });\n    });\n  }\n  /**\r\n   * Returns an instance of the MessageHandler that has successfully established a connection with an extension\r\n   * @param {Logger} logger\r\n   * @param {number} handshakeTimeoutMs\r\n   * @param {IPerformanceClient} performanceClient\r\n   * @param {ICrypto} crypto\r\n   */\n  static async createProvider(logger, handshakeTimeoutMs, performanceClient) {\n    logger.trace(\"NativeMessageHandler - createProvider called.\");\n    try {\n      const preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, NativeConstants.PREFERRED_EXTENSION_ID);\n      await preferredProvider.sendHandshakeRequest();\n      return preferredProvider;\n    } catch (e) {\n      // If preferred extension fails for whatever reason, fallback to using any installed extension\n      const backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient);\n      await backupProvider.sendHandshakeRequest();\n      return backupProvider;\n    }\n  }\n  /**\r\n   * Send handshake request helper.\r\n   */\n  async sendHandshakeRequest() {\n    this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\n    // Register this event listener before sending handshake\n    window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\n    const req = {\n      channel: NativeConstants.CHANNEL_ID,\n      extensionId: this.extensionId,\n      responseId: createNewGuid(),\n      body: {\n        method: NativeExtensionMethod.HandshakeRequest\n      }\n    };\n    this.handshakeEvent.add({\n      extensionId: this.extensionId,\n      extensionHandshakeTimeoutMs: this.handshakeTimeoutMs\n    });\n    this.messageChannel.port1.onmessage = event => {\n      this.onChannelMessage(event);\n    };\n    window.postMessage(req, window.origin, [this.messageChannel.port2]);\n    return new Promise((resolve, reject) => {\n      this.handshakeResolvers.set(req.responseId, {\n        resolve,\n        reject\n      });\n      this.timeoutId = window.setTimeout(() => {\n        /*\r\n         * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\r\n         * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\r\n         */\n        window.removeEventListener(\"message\", this.windowListener, false);\n        this.messageChannel.port1.close();\n        this.messageChannel.port2.close();\n        this.handshakeEvent.end({\n          extensionHandshakeTimedOut: true,\n          success: false\n        });\n        reject(createBrowserAuthError(nativeHandshakeTimeout));\n        this.handshakeResolvers.delete(req.responseId);\n      }, this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n    });\n  }\n  /**\r\n   * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\r\n   * @param event\r\n   */\n  onWindowMessage(event) {\n    this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\n    // We only accept messages from ourselves\n    if (event.source !== window) {\n      return;\n    }\n    const request = event.data;\n    if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n      return;\n    }\n    if (request.extensionId && request.extensionId !== this.extensionId) {\n      return;\n    }\n    if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n      const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n      /*\r\n       * Filter out responses with no matched resolvers sooner to keep channel ports open while waiting for\r\n       * the proper response.\r\n       */\n      if (!handshakeResolver) {\n        this.logger.trace(`NativeMessageHandler.onWindowMessage - resolver can't be found for request ${request.responseId}`);\n        return;\n      }\n      // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n      this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : \"No extension installed\");\n      clearTimeout(this.timeoutId);\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n      window.removeEventListener(\"message\", this.windowListener, false);\n      this.handshakeEvent.end({\n        success: false,\n        extensionInstalled: false\n      });\n      handshakeResolver.reject(createBrowserAuthError(nativeExtensionNotInstalled));\n    }\n  }\n  /**\r\n   * Invoked when a message is received from the extension on the MessageChannel port\r\n   * @param event\r\n   */\n  onChannelMessage(event) {\n    this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n    const request = event.data;\n    const resolver = this.resolvers.get(request.responseId);\n    const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n    try {\n      const method = request.body.method;\n      if (method === NativeExtensionMethod.Response) {\n        if (!resolver) {\n          return;\n        }\n        const response = request.body.response;\n        this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n        this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);\n        if (response.status !== \"Success\") {\n          resolver.reject(createNativeAuthError(response.code, response.description, response.ext));\n        } else if (response.result) {\n          if (response.result[\"code\"] && response.result[\"description\"]) {\n            resolver.reject(createNativeAuthError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n          } else {\n            resolver.resolve(response.result);\n          }\n        } else {\n          throw createAuthError(AuthErrorCodes.unexpectedError, \"Event does not contain result.\");\n        }\n        this.resolvers.delete(request.responseId);\n      } else if (method === NativeExtensionMethod.HandshakeResponse) {\n        if (!handshakeResolver) {\n          this.logger.trace(`NativeMessageHandler.onChannelMessage - resolver can't be found for request ${request.responseId}`);\n          return;\n        }\n        clearTimeout(this.timeoutId); // Clear setTimeout\n        window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n        this.extensionId = request.extensionId;\n        this.extensionVersion = request.body.version;\n        this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);\n        this.handshakeEvent.end({\n          extensionInstalled: true,\n          success: true\n        });\n        handshakeResolver.resolve();\n        this.handshakeResolvers.delete(request.responseId);\n      }\n      // Do nothing if method is not Response or HandshakeResponse\n    } catch (err) {\n      this.logger.error(\"Error parsing response from WAM Extension\");\n      this.logger.errorPii(`Error parsing response from WAM Extension: ${err}`);\n      this.logger.errorPii(`Unable to parse ${event}`);\n      if (resolver) {\n        resolver.reject(err);\n      } else if (handshakeResolver) {\n        handshakeResolver.reject(err);\n      }\n    }\n  }\n  /**\r\n   * Returns the Id for the browser extension this handler is communicating with\r\n   * @returns\r\n   */\n  getExtensionId() {\n    return this.extensionId;\n  }\n  /**\r\n   * Returns the version for the browser extension this handler is communicating with\r\n   * @returns\r\n   */\n  getExtensionVersion() {\n    return this.extensionVersion;\n  }\n  /**\r\n   * Returns boolean indicating whether or not the request should attempt to use native broker\r\n   * @param logger\r\n   * @param config\r\n   * @param nativeExtensionProvider\r\n   * @param authenticationScheme\r\n   */\n  static isNativeAvailable(config, logger, nativeExtensionProvider, authenticationScheme) {\n    logger.trace(\"isNativeAvailable called\");\n    if (!config.system.allowNativeBroker) {\n      logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\n      // Developer disabled WAM\n      return false;\n    }\n    if (!nativeExtensionProvider) {\n      logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\n      // Extension is not available\n      return false;\n    }\n    if (authenticationScheme) {\n      switch (authenticationScheme) {\n        case AuthenticationScheme.BEARER:\n        case AuthenticationScheme.POP:\n          logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n          return true;\n        default:\n          logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n          return false;\n      }\n    }\n    return true;\n  }\n}\nexport { NativeMessageHandler };","map":{"version":3,"names":["NativeMessageHandler","constructor","logger","handshakeTimeoutMs","performanceClient","extensionId","resolvers","Map","handshakeResolvers","messageChannel","MessageChannel","windowListener","onWindowMessage","bind","handshakeEvent","startMeasurement","PerformanceEvents","NativeMessageHandlerHandshake","sendMessage","body","trace","req","channel","NativeConstants","CHANNEL_ID","responseId","createNewGuid","tracePii","JSON","stringify","port1","postMessage","Promise","resolve","reject","set","createProvider","preferredProvider","PREFERRED_EXTENSION_ID","sendHandshakeRequest","e","backupProvider","window","addEventListener","method","NativeExtensionMethod","HandshakeRequest","add","extensionHandshakeTimeoutMs","onmessage","event","onChannelMessage","origin","port2","timeoutId","setTimeout","removeEventListener","close","end","extensionHandshakeTimedOut","success","createBrowserAuthError","nativeHandshakeTimeout","delete","source","request","data","handshakeResolver","get","verbose","clearTimeout","extensionInstalled","nativeExtensionNotInstalled","resolver","Response","response","status","createNativeAuthError","code","description","ext","result","createAuthError","AuthErrorCodes","unexpectedError","HandshakeResponse","extensionVersion","version","err","error","errorPii","getExtensionId","getExtensionVersion","isNativeAvailable","config","nativeExtensionProvider","authenticationScheme","system","allowNativeBroker","AuthenticationScheme","BEARER","POP"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-browser\\src\\broker\\nativeBroker\\NativeMessageHandler.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    NativeConstants,\r\n    NativeExtensionMethod,\r\n} from \"../../utils/BrowserConstants\";\r\nimport {\r\n    Logger,\r\n    AuthError,\r\n    createAuthError,\r\n    AuthErrorCodes,\r\n    AuthenticationScheme,\r\n    InProgressPerformanceEvent,\r\n    PerformanceEvents,\r\n    IPerformanceClient,\r\n} from \"@azure/msal-common\";\r\nimport {\r\n    NativeExtensionRequest,\r\n    NativeExtensionRequestBody,\r\n} from \"./NativeRequest\";\r\nimport { createNativeAuthError } from \"../../error/NativeAuthError\";\r\nimport {\r\n    createBrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../../error/BrowserAuthError\";\r\nimport { BrowserConfiguration } from \"../../config/Configuration\";\r\nimport { createNewGuid } from \"../../crypto/BrowserCrypto\";\r\n\r\ntype ResponseResolvers<T> = {\r\n    resolve: (value: T | PromiseLike<T>) => void;\r\n    reject: (\r\n        value: AuthError | Error | PromiseLike<Error> | PromiseLike<AuthError>\r\n    ) => void;\r\n};\r\n\r\nexport class NativeMessageHandler {\r\n    private extensionId: string | undefined;\r\n    private extensionVersion: string | undefined;\r\n    private logger: Logger;\r\n    private readonly handshakeTimeoutMs: number;\r\n    private timeoutId: number | undefined;\r\n    private resolvers: Map<string, ResponseResolvers<object>>;\r\n    private handshakeResolvers: Map<string, ResponseResolvers<void>>;\r\n    private messageChannel: MessageChannel;\r\n    private readonly windowListener: (event: MessageEvent) => void;\r\n    private readonly performanceClient: IPerformanceClient;\r\n    private readonly handshakeEvent: InProgressPerformanceEvent;\r\n\r\n    constructor(\r\n        logger: Logger,\r\n        handshakeTimeoutMs: number,\r\n        performanceClient: IPerformanceClient,\r\n        extensionId?: string\r\n    ) {\r\n        this.logger = logger;\r\n        this.handshakeTimeoutMs = handshakeTimeoutMs;\r\n        this.extensionId = extensionId;\r\n        this.resolvers = new Map(); // Used for non-handshake messages\r\n        this.handshakeResolvers = new Map(); // Used for handshake messages\r\n        this.messageChannel = new MessageChannel();\r\n        this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\r\n        this.performanceClient = performanceClient;\r\n        this.handshakeEvent = performanceClient.startMeasurement(\r\n            PerformanceEvents.NativeMessageHandlerHandshake\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sends a given message to the extension and resolves with the extension response\r\n     * @param body\r\n     */\r\n    async sendMessage(body: NativeExtensionRequestBody): Promise<object> {\r\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\r\n        const req: NativeExtensionRequest = {\r\n            channel: NativeConstants.CHANNEL_ID,\r\n            extensionId: this.extensionId,\r\n            responseId: createNewGuid(),\r\n            body: body,\r\n        };\r\n\r\n        this.logger.trace(\r\n            \"NativeMessageHandler - Sending request to browser extension\"\r\n        );\r\n        this.logger.tracePii(\r\n            `NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(\r\n                req\r\n            )}`\r\n        );\r\n        this.messageChannel.port1.postMessage(req);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.resolvers.set(req.responseId, { resolve, reject });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns an instance of the MessageHandler that has successfully established a connection with an extension\r\n     * @param {Logger} logger\r\n     * @param {number} handshakeTimeoutMs\r\n     * @param {IPerformanceClient} performanceClient\r\n     * @param {ICrypto} crypto\r\n     */\r\n    static async createProvider(\r\n        logger: Logger,\r\n        handshakeTimeoutMs: number,\r\n        performanceClient: IPerformanceClient\r\n    ): Promise<NativeMessageHandler> {\r\n        logger.trace(\"NativeMessageHandler - createProvider called.\");\r\n        try {\r\n            const preferredProvider = new NativeMessageHandler(\r\n                logger,\r\n                handshakeTimeoutMs,\r\n                performanceClient,\r\n                NativeConstants.PREFERRED_EXTENSION_ID\r\n            );\r\n            await preferredProvider.sendHandshakeRequest();\r\n            return preferredProvider;\r\n        } catch (e) {\r\n            // If preferred extension fails for whatever reason, fallback to using any installed extension\r\n            const backupProvider = new NativeMessageHandler(\r\n                logger,\r\n                handshakeTimeoutMs,\r\n                performanceClient\r\n            );\r\n            await backupProvider.sendHandshakeRequest();\r\n            return backupProvider;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send handshake request helper.\r\n     */\r\n    private async sendHandshakeRequest(): Promise<void> {\r\n        this.logger.trace(\r\n            \"NativeMessageHandler - sendHandshakeRequest called.\"\r\n        );\r\n        // Register this event listener before sending handshake\r\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\r\n\r\n        const req: NativeExtensionRequest = {\r\n            channel: NativeConstants.CHANNEL_ID,\r\n            extensionId: this.extensionId,\r\n            responseId: createNewGuid(),\r\n            body: {\r\n                method: NativeExtensionMethod.HandshakeRequest,\r\n            },\r\n        };\r\n        this.handshakeEvent.add({\r\n            extensionId: this.extensionId,\r\n            extensionHandshakeTimeoutMs: this.handshakeTimeoutMs,\r\n        });\r\n\r\n        this.messageChannel.port1.onmessage = (event) => {\r\n            this.onChannelMessage(event);\r\n        };\r\n\r\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.handshakeResolvers.set(req.responseId, { resolve, reject });\r\n            this.timeoutId = window.setTimeout(() => {\r\n                /*\r\n                 * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\r\n                 * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\r\n                 */\r\n                window.removeEventListener(\r\n                    \"message\",\r\n                    this.windowListener,\r\n                    false\r\n                );\r\n                this.messageChannel.port1.close();\r\n                this.messageChannel.port2.close();\r\n                this.handshakeEvent.end({\r\n                    extensionHandshakeTimedOut: true,\r\n                    success: false,\r\n                });\r\n                reject(\r\n                    createBrowserAuthError(\r\n                        BrowserAuthErrorCodes.nativeHandshakeTimeout\r\n                    )\r\n                );\r\n                this.handshakeResolvers.delete(req.responseId);\r\n            }, this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\r\n     * @param event\r\n     */\r\n    private onWindowMessage(event: MessageEvent): void {\r\n        this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\r\n        // We only accept messages from ourselves\r\n        if (event.source !== window) {\r\n            return;\r\n        }\r\n\r\n        const request = event.data;\r\n\r\n        if (\r\n            !request.channel ||\r\n            request.channel !== NativeConstants.CHANNEL_ID\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        if (request.extensionId && request.extensionId !== this.extensionId) {\r\n            return;\r\n        }\r\n\r\n        if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\r\n            const handshakeResolver = this.handshakeResolvers.get(\r\n                request.responseId\r\n            );\r\n            /*\r\n             * Filter out responses with no matched resolvers sooner to keep channel ports open while waiting for\r\n             * the proper response.\r\n             */\r\n            if (!handshakeResolver) {\r\n                this.logger.trace(\r\n                    `NativeMessageHandler.onWindowMessage - resolver can't be found for request ${request.responseId}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\r\n            this.logger.verbose(\r\n                request.extensionId\r\n                    ? `Extension with id: ${request.extensionId} not installed`\r\n                    : \"No extension installed\"\r\n            );\r\n            clearTimeout(this.timeoutId);\r\n            this.messageChannel.port1.close();\r\n            this.messageChannel.port2.close();\r\n            window.removeEventListener(\"message\", this.windowListener, false);\r\n            this.handshakeEvent.end({\r\n                success: false,\r\n                extensionInstalled: false,\r\n            });\r\n            handshakeResolver.reject(\r\n                createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.nativeExtensionNotInstalled\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invoked when a message is received from the extension on the MessageChannel port\r\n     * @param event\r\n     */\r\n    private onChannelMessage(event: MessageEvent): void {\r\n        this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\r\n        const request = event.data;\r\n\r\n        const resolver = this.resolvers.get(request.responseId);\r\n        const handshakeResolver = this.handshakeResolvers.get(\r\n            request.responseId\r\n        );\r\n\r\n        try {\r\n            const method = request.body.method;\r\n\r\n            if (method === NativeExtensionMethod.Response) {\r\n                if (!resolver) {\r\n                    return;\r\n                }\r\n                const response = request.body.response;\r\n                this.logger.trace(\r\n                    \"NativeMessageHandler - Received response from browser extension\"\r\n                );\r\n                this.logger.tracePii(\r\n                    `NativeMessageHandler - Received response from browser extension: ${JSON.stringify(\r\n                        response\r\n                    )}`\r\n                );\r\n                if (response.status !== \"Success\") {\r\n                    resolver.reject(\r\n                        createNativeAuthError(\r\n                            response.code,\r\n                            response.description,\r\n                            response.ext\r\n                        )\r\n                    );\r\n                } else if (response.result) {\r\n                    if (\r\n                        response.result[\"code\"] &&\r\n                        response.result[\"description\"]\r\n                    ) {\r\n                        resolver.reject(\r\n                            createNativeAuthError(\r\n                                response.result[\"code\"],\r\n                                response.result[\"description\"],\r\n                                response.result[\"ext\"]\r\n                            )\r\n                        );\r\n                    } else {\r\n                        resolver.resolve(response.result);\r\n                    }\r\n                } else {\r\n                    throw createAuthError(\r\n                        AuthErrorCodes.unexpectedError,\r\n                        \"Event does not contain result.\"\r\n                    );\r\n                }\r\n                this.resolvers.delete(request.responseId);\r\n            } else if (method === NativeExtensionMethod.HandshakeResponse) {\r\n                if (!handshakeResolver) {\r\n                    this.logger.trace(\r\n                        `NativeMessageHandler.onChannelMessage - resolver can't be found for request ${request.responseId}`\r\n                    );\r\n                    return;\r\n                }\r\n                clearTimeout(this.timeoutId); // Clear setTimeout\r\n                window.removeEventListener(\r\n                    \"message\",\r\n                    this.windowListener,\r\n                    false\r\n                ); // Remove 'No extension' listener\r\n                this.extensionId = request.extensionId;\r\n                this.extensionVersion = request.body.version;\r\n                this.logger.verbose(\r\n                    `NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`\r\n                );\r\n                this.handshakeEvent.end({\r\n                    extensionInstalled: true,\r\n                    success: true,\r\n                });\r\n\r\n                handshakeResolver.resolve();\r\n                this.handshakeResolvers.delete(request.responseId);\r\n            }\r\n            // Do nothing if method is not Response or HandshakeResponse\r\n        } catch (err) {\r\n            this.logger.error(\"Error parsing response from WAM Extension\");\r\n            this.logger.errorPii(\r\n                `Error parsing response from WAM Extension: ${err as string}`\r\n            );\r\n            this.logger.errorPii(`Unable to parse ${event}`);\r\n\r\n            if (resolver) {\r\n                resolver.reject(err as AuthError);\r\n            } else if (handshakeResolver) {\r\n                handshakeResolver.reject(err as AuthError);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the Id for the browser extension this handler is communicating with\r\n     * @returns\r\n     */\r\n    getExtensionId(): string | undefined {\r\n        return this.extensionId;\r\n    }\r\n\r\n    /**\r\n     * Returns the version for the browser extension this handler is communicating with\r\n     * @returns\r\n     */\r\n    getExtensionVersion(): string | undefined {\r\n        return this.extensionVersion;\r\n    }\r\n\r\n    /**\r\n     * Returns boolean indicating whether or not the request should attempt to use native broker\r\n     * @param logger\r\n     * @param config\r\n     * @param nativeExtensionProvider\r\n     * @param authenticationScheme\r\n     */\r\n    static isNativeAvailable(\r\n        config: BrowserConfiguration,\r\n        logger: Logger,\r\n        nativeExtensionProvider?: NativeMessageHandler,\r\n        authenticationScheme?: AuthenticationScheme\r\n    ): boolean {\r\n        logger.trace(\"isNativeAvailable called\");\r\n        if (!config.system.allowNativeBroker) {\r\n            logger.trace(\r\n                \"isNativeAvailable: allowNativeBroker is not enabled, returning false\"\r\n            );\r\n            // Developer disabled WAM\r\n            return false;\r\n        }\r\n\r\n        if (!nativeExtensionProvider) {\r\n            logger.trace(\r\n                \"isNativeAvailable: WAM extension provider is not initialized, returning false\"\r\n            );\r\n            // Extension is not available\r\n            return false;\r\n        }\r\n\r\n        if (authenticationScheme) {\r\n            switch (authenticationScheme) {\r\n                case AuthenticationScheme.BEARER:\r\n                case AuthenticationScheme.POP:\r\n                    logger.trace(\r\n                        \"isNativeAvailable: authenticationScheme is supported, returning true\"\r\n                    );\r\n                    return true;\r\n                default:\r\n                    logger.trace(\r\n                        \"isNativeAvailable: authenticationScheme is not supported, returning false\"\r\n                    );\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;;;AAAA;;;AAGG;MAmCUA,oBAAoB;EAa7BC,YACIC,MAAc,EACdC,kBAA0B,EAC1BC,iBAAqC,EACrCC,WAAoB;IAEpB,IAAI,CAACH,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACE,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,SAAS,GAAG,IAAIC,GAAG,EAAE,CAAC;IAC3B,IAAI,CAACC,kBAAkB,GAAG,IAAID,GAAG,EAAE,CAAC;IACpC,IAAI,CAACE,cAAc,GAAG,IAAIC,cAAc,EAAE;IAC1C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,eAAe,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACtD,IAAI,CAACT,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACU,cAAc,GAAGV,iBAAiB,CAACW,gBAAgB,CACpDC,iBAAiB,CAACC,6BAA6B,CAClD;;EAGL;;;AAGG;EACH,MAAMC,WAAWA,CAACC,IAAgC;IAC9C,IAAI,CAACjB,MAAM,CAACkB,KAAK,CAAC,4CAA4C,CAAC;IAC/D,MAAMC,GAAG,GAA2B;MAChCC,OAAO,EAAEC,eAAe,CAACC,UAAU;MACnCnB,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BoB,UAAU,EAAEC,aAAa,EAAE;MAC3BP,IAAI,EAAEA;KACT;IAED,IAAI,CAACjB,MAAM,CAACkB,KAAK,CACb,6DAA6D,CAChE;IACD,IAAI,CAAClB,MAAM,CAACyB,QAAQ,CACgD,gEAAAC,IAAI,CAACC,SAAS,CAC1ER,GAAG,CACN,EAAE,CACN;IACD,IAAI,CAACZ,cAAc,CAACqB,KAAK,CAACC,WAAW,CAACV,GAAG,CAAC;IAE1C,OAAO,IAAIW,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACnC,IAAI,CAAC5B,SAAS,CAAC6B,GAAG,CAACd,GAAG,CAACI,UAAU,EAAE;QAAEQ,OAAO;QAAEC;MAAM,CAAE,CAAC;IAC3D,CAAC,CAAC;;EAGN;;;;;;AAMG;EACH,aAAaE,cAAcA,CACvBlC,MAAc,EACdC,kBAA0B,EAC1BC,iBAAqC;IAErCF,MAAM,CAACkB,KAAK,CAAC,+CAA+C,CAAC;IAC7D,IAAI;MACA,MAAMiB,iBAAiB,GAAG,IAAIrC,oBAAoB,CAC9CE,MAAM,EACNC,kBAAkB,EAClBC,iBAAiB,EACjBmB,eAAe,CAACe,sBAAsB,CACzC;MACD,MAAMD,iBAAiB,CAACE,oBAAoB,EAAE;MAC9C,OAAOF,iBAAiB;IAC3B,EAAC,OAAOG,CAAC,EAAE;;MAER,MAAMC,cAAc,GAAG,IAAIzC,oBAAoB,CAC3CE,MAAM,EACNC,kBAAkB,EAClBC,iBAAiB,CACpB;MACD,MAAMqC,cAAc,CAACF,oBAAoB,EAAE;MAC3C,OAAOE,cAAc;IACxB;;EAGL;;AAEG;EACK,MAAMF,oBAAoBA,CAAA;IAC9B,IAAI,CAACrC,MAAM,CAACkB,KAAK,CACb,qDAAqD,CACxD;;IAEDsB,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAChC,cAAc,EAAE,KAAK,CAAC,CAAC;IAE/D,MAAMU,GAAG,GAA2B;MAChCC,OAAO,EAAEC,eAAe,CAACC,UAAU;MACnCnB,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BoB,UAAU,EAAEC,aAAa,EAAE;MAC3BP,IAAI,EAAE;QACFyB,MAAM,EAAEC,qBAAqB,CAACC;MACjC;KACJ;IACD,IAAI,CAAChC,cAAc,CAACiC,GAAG,CAAC;MACpB1C,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7B2C,2BAA2B,EAAE,IAAI,CAAC7C;IACrC,EAAC;IAEF,IAAI,CAACM,cAAc,CAACqB,KAAK,CAACmB,SAAS,GAAIC,KAAK,IAAI;MAC5C,IAAI,CAACC,gBAAgB,CAACD,KAAK,CAAC;IAChC,CAAC;IAEDR,MAAM,CAACX,WAAW,CAACV,GAAG,EAAEqB,MAAM,CAACU,MAAM,EAAE,CAAC,IAAI,CAAC3C,cAAc,CAAC4C,KAAK,CAAC,CAAC;IAEnE,OAAO,IAAIrB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACnC,IAAI,CAAC1B,kBAAkB,CAAC2B,GAAG,CAACd,GAAG,CAACI,UAAU,EAAE;QAAEQ,OAAO;QAAEC;MAAM,CAAE,CAAC;MAChE,IAAI,CAACoB,SAAS,GAAGZ,MAAM,CAACa,UAAU,CAAC,MAAK;QACpC;;;AAGG;QACHb,MAAM,CAACc,mBAAmB,CACtB,SAAS,EACT,IAAI,CAAC7C,cAAc,EACnB,KAAK,CACR;QACD,IAAI,CAACF,cAAc,CAACqB,KAAK,CAAC2B,KAAK,EAAE;QACjC,IAAI,CAAChD,cAAc,CAAC4C,KAAK,CAACI,KAAK,EAAE;QACjC,IAAI,CAAC3C,cAAc,CAAC4C,GAAG,CAAC;UACpBC,0BAA0B,EAAE,IAAI;UAChCC,OAAO,EAAE;QACZ,EAAC;QACF1B,MAAM,CACF2B,sBAAsB,CAClBC,sBAA4C,CAC/C,CACJ;QACD,IAAI,CAACtD,kBAAkB,CAACuD,MAAM,CAAC1C,GAAG,CAACI,UAAU,CAAC;MAClD,CAAC,EAAE,IAAI,CAACtB,kBAAkB,CAAC,CAAC;IAChC,CAAC,CAAC;;EAGN;;;AAGG;EACKS,eAAeA,CAACsC,KAAmB;IACvC,IAAI,CAAChD,MAAM,CAACkB,KAAK,CAAC,+CAA+C,CAAC;;IAElE,IAAI8B,KAAK,CAACc,MAAM,KAAKtB,MAAM,EAAE;MACzB;IACH;IAED,MAAMuB,OAAO,GAAGf,KAAK,CAACgB,IAAI;IAE1B,IACI,CAACD,OAAO,CAAC3C,OAAO,IAChB2C,OAAO,CAAC3C,OAAO,KAAKC,eAAe,CAACC,UAAU,EAChD;MACE;IACH;IAED,IAAIyC,OAAO,CAAC5D,WAAW,IAAI4D,OAAO,CAAC5D,WAAW,KAAK,IAAI,CAACA,WAAW,EAAE;MACjE;IACH;IAED,IAAI4D,OAAO,CAAC9C,IAAI,CAACyB,MAAM,KAAKC,qBAAqB,CAACC,gBAAgB,EAAE;MAChE,MAAMqB,iBAAiB,GAAG,IAAI,CAAC3D,kBAAkB,CAAC4D,GAAG,CACjDH,OAAO,CAACxC,UAAU,CACrB;MACD;;;AAGG;MACH,IAAI,CAAC0C,iBAAiB,EAAE;QACpB,IAAI,CAACjE,MAAM,CAACkB,KAAK,CACiE,8EAAA6C,OAAO,CAACxC,UAAY,GACrG;QACD;MACH;;MAGD,IAAI,CAACvB,MAAM,CAACmE,OAAO,CACfJ,OAAO,CAAC5D,WAAW,GACb,sBAAsB4D,OAAO,CAAC5D,WAA2B,mBACzD,wBAAwB,CACjC;MACDiE,YAAY,CAAC,IAAI,CAAChB,SAAS,CAAC;MAC5B,IAAI,CAAC7C,cAAc,CAACqB,KAAK,CAAC2B,KAAK,EAAE;MACjC,IAAI,CAAChD,cAAc,CAAC4C,KAAK,CAACI,KAAK,EAAE;MACjCf,MAAM,CAACc,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC7C,cAAc,EAAE,KAAK,CAAC;MACjE,IAAI,CAACG,cAAc,CAAC4C,GAAG,CAAC;QACpBE,OAAO,EAAE,KAAK;QACdW,kBAAkB,EAAE;MACvB,EAAC;MACFJ,iBAAiB,CAACjC,MAAM,CACpB2B,sBAAsB,CAClBW,2BAAiD,CACpD,CACJ;IACJ;;EAGL;;;AAGG;EACKrB,gBAAgBA,CAACD,KAAmB;IACxC,IAAI,CAAChD,MAAM,CAACkB,KAAK,CAAC,iDAAiD,CAAC;IACpE,MAAM6C,OAAO,GAAGf,KAAK,CAACgB,IAAI;IAE1B,MAAMO,QAAQ,GAAG,IAAI,CAACnE,SAAS,CAAC8D,GAAG,CAACH,OAAO,CAACxC,UAAU,CAAC;IACvD,MAAM0C,iBAAiB,GAAG,IAAI,CAAC3D,kBAAkB,CAAC4D,GAAG,CACjDH,OAAO,CAACxC,UAAU,CACrB;IAED,IAAI;MACA,MAAMmB,MAAM,GAAGqB,OAAO,CAAC9C,IAAI,CAACyB,MAAM;MAElC,IAAIA,MAAM,KAAKC,qBAAqB,CAAC6B,QAAQ,EAAE;QAC3C,IAAI,CAACD,QAAQ,EAAE;UACX;QACH;QACD,MAAME,QAAQ,GAAGV,OAAO,CAAC9C,IAAI,CAACwD,QAAQ;QACtC,IAAI,CAACzE,MAAM,CAACkB,KAAK,CACb,iEAAiE,CACpE;QACD,IAAI,CAAClB,MAAM,CAACyB,QAAQ,CACoD,oEAAAC,IAAI,CAACC,SAAS,CAC9E8C,QAAQ,CACX,EAAE,CACN;QACD,IAAIA,QAAQ,CAACC,MAAM,KAAK,SAAS,EAAE;UAC/BH,QAAQ,CAACvC,MAAM,CACX2C,qBAAqB,CACjBF,QAAQ,CAACG,IAAI,EACbH,QAAQ,CAACI,WAAW,EACpBJ,QAAQ,CAACK,GAAG,CACf,CACJ;QACJ,OAAM,IAAIL,QAAQ,CAACM,MAAM,EAAE;UACxB,IACIN,QAAQ,CAACM,MAAM,CAAC,MAAM,CAAC,IACvBN,QAAQ,CAACM,MAAM,CAAC,aAAa,CAAC,EAChC;YACER,QAAQ,CAACvC,MAAM,CACX2C,qBAAqB,CACjBF,QAAQ,CAACM,MAAM,CAAC,MAAM,CAAC,EACvBN,QAAQ,CAACM,MAAM,CAAC,aAAa,CAAC,EAC9BN,QAAQ,CAACM,MAAM,CAAC,KAAK,CAAC,CACzB,CACJ;UACJ,OAAM;YACHR,QAAQ,CAACxC,OAAO,CAAC0C,QAAQ,CAACM,MAAM,CAAC;UACpC;QACJ,OAAM;UACH,MAAMC,eAAe,CACjBC,cAAc,CAACC,eAAe,EAC9B,gCAAgC,CACnC;QACJ;QACD,IAAI,CAAC9E,SAAS,CAACyD,MAAM,CAACE,OAAO,CAACxC,UAAU,CAAC;MAC5C,OAAM,IAAImB,MAAM,KAAKC,qBAAqB,CAACwC,iBAAiB,EAAE;QAC3D,IAAI,CAAClB,iBAAiB,EAAE;UACpB,IAAI,CAACjE,MAAM,CAACkB,KAAK,CACkE,+EAAA6C,OAAO,CAACxC,UAAY,GACtG;UACD;QACH;QACD6C,YAAY,CAAC,IAAI,CAAChB,SAAS,CAAC,CAAC;QAC7BZ,MAAM,CAACc,mBAAmB,CACtB,SAAS,EACT,IAAI,CAAC7C,cAAc,EACnB,KAAK,CACR,CAAC;QACF,IAAI,CAACN,WAAW,GAAG4D,OAAO,CAAC5D,WAAW;QACtC,IAAI,CAACiF,gBAAgB,GAAGrB,OAAO,CAAC9C,IAAI,CAACoE,OAAO;QAC5C,IAAI,CAACrF,MAAM,CAACmE,OAAO,CACsD,yEAAI,CAAChE,WAAa,GAC1F;QACD,IAAI,CAACS,cAAc,CAAC4C,GAAG,CAAC;UACpBa,kBAAkB,EAAE,IAAI;UACxBX,OAAO,EAAE;QACZ,EAAC;QAEFO,iBAAiB,CAAClC,OAAO,EAAE;QAC3B,IAAI,CAACzB,kBAAkB,CAACuD,MAAM,CAACE,OAAO,CAACxC,UAAU,CAAC;MACrD;;IAEJ,EAAC,OAAO+D,GAAG,EAAE;MACV,IAAI,CAACtF,MAAM,CAACuF,KAAK,CAAC,2CAA2C,CAAC;MAC9D,IAAI,CAACvF,MAAM,CAACwF,QAAQ,CAC8B,8CAAAF,GAAe,GAChE;MACD,IAAI,CAACtF,MAAM,CAACwF,QAAQ,CAAoB,mBAAAxC,KAAO,GAAC;MAEhD,IAAIuB,QAAQ,EAAE;QACVA,QAAQ,CAACvC,MAAM,CAACsD,GAAgB,CAAC;MACpC,OAAM,IAAIrB,iBAAiB,EAAE;QAC1BA,iBAAiB,CAACjC,MAAM,CAACsD,GAAgB,CAAC;MAC7C;IACJ;;EAGL;;;AAGG;EACHG,cAAcA,CAAA;IACV,OAAO,IAAI,CAACtF,WAAW;;EAG3B;;;AAGG;EACHuF,mBAAmBA,CAAA;IACf,OAAO,IAAI,CAACN,gBAAgB;;EAGhC;;;;;;AAMG;EACH,OAAOO,iBAAiBA,CACpBC,MAA4B,EAC5B5F,MAAc,EACd6F,uBAA8C,EAC9CC,oBAA2C;IAE3C9F,MAAM,CAACkB,KAAK,CAAC,0BAA0B,CAAC;IACxC,IAAI,CAAC0E,MAAM,CAACG,MAAM,CAACC,iBAAiB,EAAE;MAClChG,MAAM,CAACkB,KAAK,CACR,sEAAsE,CACzE;;MAED,OAAO,KAAK;IACf;IAED,IAAI,CAAC2E,uBAAuB,EAAE;MAC1B7F,MAAM,CAACkB,KAAK,CACR,+EAA+E,CAClF;;MAED,OAAO,KAAK;IACf;IAED,IAAI4E,oBAAoB,EAAE;MACtB,QAAQA,oBAAoB;QACxB,KAAKG,oBAAoB,CAACC,MAAM;QAChC,KAAKD,oBAAoB,CAACE,GAAG;UACzBnG,MAAM,CAACkB,KAAK,CACR,sEAAsE,CACzE;UACD,OAAO,IAAI;QACf;UACIlB,MAAM,CAACkB,KAAK,CACR,2EAA2E,CAC9E;UACD,OAAO,KAAK;MACnB;IACJ;IAED,OAAO,IAAI;;AAElB"},"metadata":{},"sourceType":"module","externalDependencies":[]}