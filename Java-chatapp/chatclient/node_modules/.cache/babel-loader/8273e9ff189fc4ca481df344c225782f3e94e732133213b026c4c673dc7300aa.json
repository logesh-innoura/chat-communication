{"ast":null,"code":"/*! @azure/msal-common v14.6.0 2024-01-09 */\n'use strict';\n\nimport { Constants, ResponseCodes, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass RegionDiscovery {\n  constructor(networkInterface, logger, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  async detectRegion(environmentRegion, regionDiscoveryMetadata) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n    // Initialize auto detected region with the region from the envrionment\n    let autodetectedRegionName = environmentRegion;\n    // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n    if (!autodetectedRegionName) {\n      const options = RegionDiscovery.IMDS_OPTIONS;\n      try {\n        const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);\n        if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n          autodetectedRegionName = localIMDSVersionResponse.body;\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n        }\n        // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n        if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\n          const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);\n          if (!currentIMDSVersion) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return null;\n          }\n          const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);\n          if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n            autodetectedRegionName = currentIMDSVersionResponse.body;\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n          }\n        }\n      } catch (e) {\n        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        return null;\n      }\n    } else {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n    }\n    // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n    if (!autodetectedRegionName) {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n    }\n    return autodetectedRegionName || null;\n  }\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n  async getRegionFromIMDS(version, options) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n    return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n  }\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  async getCurrentVersion(options) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n    try {\n      const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n      // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n      if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n        return response.body[\"newest-versions\"][0];\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n// Options for the IMDS endpoint request\nRegionDiscovery.IMDS_OPTIONS = {\n  headers: {\n    Metadata: \"true\"\n  }\n};\nexport { RegionDiscovery };","map":{"version":3,"names":["RegionDiscovery","constructor","networkInterface","logger","performanceClient","correlationId","detectRegion","environmentRegion","regionDiscoveryMetadata","addQueueMeasurement","PerformanceEvents","RegionDiscoveryDetectRegion","autodetectedRegionName","options","IMDS_OPTIONS","localIMDSVersionResponse","invokeAsync","getRegionFromIMDS","bind","RegionDiscoveryGetRegionFromIMDS","Constants","IMDS_VERSION","status","ResponseCodes","httpSuccess","body","region_source","RegionDiscoverySources","IMDS","httpBadRequest","currentIMDSVersion","getCurrentVersion","RegionDiscoveryGetCurrentVersion","FAILED_AUTO_DETECTION","currentIMDSVersionResponse","e","ENVIRONMENT_VARIABLE","version","sendGetRequestAsync","IMDS_ENDPOINT","IMDS_TIMEOUT","response","length","headers","Metadata"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-common\\src\\authority\\RegionDiscovery.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse\";\r\nimport {\r\n    Constants,\r\n    RegionDiscoverySources,\r\n    ResponseCodes,\r\n} from \"../utils/Constants\";\r\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\r\nimport { ImdsOptions } from \"./ImdsOptions\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\nimport { invokeAsync } from \"../utils/FunctionWrappers\";\r\nimport { Logger } from \"../logger/Logger\";\r\n\r\nexport class RegionDiscovery {\r\n    // Network interface to make requests with.\r\n    protected networkInterface: INetworkModule;\r\n    // Logger\r\n    private logger: Logger;\r\n    // Performance client\r\n    protected performanceClient: IPerformanceClient | undefined;\r\n    // CorrelationId\r\n    protected correlationId: string | undefined;\r\n    // Options for the IMDS endpoint request\r\n    protected static IMDS_OPTIONS: ImdsOptions = {\r\n        headers: {\r\n            Metadata: \"true\",\r\n        },\r\n    };\r\n\r\n    constructor(\r\n        networkInterface: INetworkModule,\r\n        logger: Logger,\r\n        performanceClient?: IPerformanceClient,\r\n        correlationId?: string\r\n    ) {\r\n        this.networkInterface = networkInterface;\r\n        this.logger = logger;\r\n        this.performanceClient = performanceClient;\r\n        this.correlationId = correlationId;\r\n    }\r\n\r\n    /**\r\n     * Detect the region from the application's environment.\r\n     *\r\n     * @returns Promise<string | null>\r\n     */\r\n    public async detectRegion(\r\n        environmentRegion: string | undefined,\r\n        regionDiscoveryMetadata: RegionDiscoveryMetadata\r\n    ): Promise<string | null> {\r\n        this.performanceClient?.addQueueMeasurement(\r\n            PerformanceEvents.RegionDiscoveryDetectRegion,\r\n            this.correlationId\r\n        );\r\n\r\n        // Initialize auto detected region with the region from the envrionment\r\n        let autodetectedRegionName = environmentRegion;\r\n\r\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\r\n        if (!autodetectedRegionName) {\r\n            const options = RegionDiscovery.IMDS_OPTIONS;\r\n\r\n            try {\r\n                const localIMDSVersionResponse = await invokeAsync(\r\n                    this.getRegionFromIMDS.bind(this),\r\n                    PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\r\n                    this.logger,\r\n                    this.performanceClient,\r\n                    this.correlationId\r\n                )(Constants.IMDS_VERSION, options);\r\n                if (\r\n                    localIMDSVersionResponse.status ===\r\n                    ResponseCodes.httpSuccess\r\n                ) {\r\n                    autodetectedRegionName = localIMDSVersionResponse.body;\r\n                    regionDiscoveryMetadata.region_source =\r\n                        RegionDiscoverySources.IMDS;\r\n                }\r\n\r\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\r\n                if (\r\n                    localIMDSVersionResponse.status ===\r\n                    ResponseCodes.httpBadRequest\r\n                ) {\r\n                    const currentIMDSVersion = await invokeAsync(\r\n                        this.getCurrentVersion.bind(this),\r\n                        PerformanceEvents.RegionDiscoveryGetCurrentVersion,\r\n                        this.logger,\r\n                        this.performanceClient,\r\n                        this.correlationId\r\n                    )(options);\r\n                    if (!currentIMDSVersion) {\r\n                        regionDiscoveryMetadata.region_source =\r\n                            RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                        return null;\r\n                    }\r\n\r\n                    const currentIMDSVersionResponse = await invokeAsync(\r\n                        this.getRegionFromIMDS.bind(this),\r\n                        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\r\n                        this.logger,\r\n                        this.performanceClient,\r\n                        this.correlationId\r\n                    )(currentIMDSVersion, options);\r\n                    if (\r\n                        currentIMDSVersionResponse.status ===\r\n                        ResponseCodes.httpSuccess\r\n                    ) {\r\n                        autodetectedRegionName =\r\n                            currentIMDSVersionResponse.body;\r\n                        regionDiscoveryMetadata.region_source =\r\n                            RegionDiscoverySources.IMDS;\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                regionDiscoveryMetadata.region_source =\r\n                    RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                return null;\r\n            }\r\n        } else {\r\n            regionDiscoveryMetadata.region_source =\r\n                RegionDiscoverySources.ENVIRONMENT_VARIABLE;\r\n        }\r\n\r\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\r\n        if (!autodetectedRegionName) {\r\n            regionDiscoveryMetadata.region_source =\r\n                RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n        }\r\n\r\n        return autodetectedRegionName || null;\r\n    }\r\n\r\n    /**\r\n     * Make the call to the IMDS endpoint\r\n     *\r\n     * @param imdsEndpointUrl\r\n     * @returns Promise<NetworkResponse<string>>\r\n     */\r\n    private async getRegionFromIMDS(\r\n        version: string,\r\n        options: ImdsOptions\r\n    ): Promise<NetworkResponse<string>> {\r\n        this.performanceClient?.addQueueMeasurement(\r\n            PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\r\n            this.correlationId\r\n        );\r\n        return this.networkInterface.sendGetRequestAsync<string>(\r\n            `${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`,\r\n            options,\r\n            Constants.IMDS_TIMEOUT\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the most recent version of the IMDS endpoint available\r\n     *\r\n     * @returns Promise<string | null>\r\n     */\r\n    private async getCurrentVersion(\r\n        options: ImdsOptions\r\n    ): Promise<string | null> {\r\n        this.performanceClient?.addQueueMeasurement(\r\n            PerformanceEvents.RegionDiscoveryGetCurrentVersion,\r\n            this.correlationId\r\n        );\r\n        try {\r\n            const response =\r\n                await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(\r\n                    `${Constants.IMDS_ENDPOINT}?format=json`,\r\n                    options\r\n                );\r\n\r\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\r\n            if (\r\n                response.status === ResponseCodes.httpBadRequest &&\r\n                response.body &&\r\n                response.body[\"newest-versions\"] &&\r\n                response.body[\"newest-versions\"].length > 0\r\n            ) {\r\n                return response.body[\"newest-versions\"][0];\r\n            }\r\n\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}