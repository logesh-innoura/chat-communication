{"ast":null,"code":"/*! @azure/msal-browser v3.7.0 2024-01-09 */\n'use strict';\n\nimport { BridgeStatusCode } from './BridgeStatusCode.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * BridgeProxy\r\n * Provides a proxy for accessing a bridge to a host app and/or\r\n * platform broker\r\n */\nclass BridgeProxy {\n  /**\r\n   * initializeNestedAppAuthBridge - Initializes the bridge to the host app\r\n   * @returns a promise that resolves to an InitializeBridgeResponse or rejects with an Error\r\n   * @remarks This method will be called by the create factory method\r\n   * @remarks If the bridge is not available, this method will throw an error\r\n   */\n  static async initializeNestedAppAuthBridge() {\n    if (window === undefined) {\n      throw new Error(\"window is undefined\");\n    }\n    if (window.nestedAppAuthBridge === undefined) {\n      throw new Error(\"window.nestedAppAuthBridge is undefined\");\n    }\n    if (window.crypto === undefined) {\n      throw new Error(\"window.crypto is undefined\");\n    }\n    try {\n      BridgeProxy.crypto = window.crypto;\n      window.nestedAppAuthBridge.addEventListener(\"message\", response => {\n        const responsePayload = typeof response === \"string\" ? response : response.data;\n        const responseEnvelope = JSON.parse(responsePayload);\n        const request = BridgeProxy.bridgeRequests.find(element => element.requestId === responseEnvelope.requestId);\n        if (request !== undefined) {\n          BridgeProxy.bridgeRequests.splice(BridgeProxy.bridgeRequests.indexOf(request), 1);\n          if (responseEnvelope.success) {\n            request.resolve(responseEnvelope);\n          } else {\n            request.reject(responseEnvelope.error);\n          }\n        }\n      });\n      const bridgeResponse = await new Promise((resolve, reject) => {\n        const message = {\n          messageType: \"NestedAppAuthRequest\",\n          method: \"GetInitContext\",\n          requestId: BridgeProxy.getRandomId()\n        };\n        const request = {\n          requestId: message.requestId,\n          method: message.method,\n          resolve: resolve,\n          reject: reject\n        };\n        BridgeProxy.bridgeRequests.push(request);\n        window.nestedAppAuthBridge.postMessage(JSON.stringify(message));\n      });\n      return BridgeProxy.validateBridgeResultOrThrow(bridgeResponse.initContext);\n    } catch (error) {\n      window.console.log(error);\n      throw error;\n    }\n  }\n  static getRandomId() {\n    return BridgeProxy.crypto.randomUUID();\n  }\n  /**\r\n   * getTokenInteractive - Attempts to get a token interactively from the bridge\r\n   * @param request A token request\r\n   * @returns a promise that resolves to an auth result or rejects with a BridgeError\r\n   */\n  getTokenInteractive(request) {\n    return this.getToken(\"GetTokenPopup\", request);\n  }\n  /**\r\n   * getTokenSilent Attempts to get a token silently from the bridge\r\n   * @param request A token request\r\n   * @returns a promise that resolves to an auth result or rejects with a BridgeError\r\n   */\n  getTokenSilent(request) {\n    return this.getToken(\"GetToken\", request);\n  }\n  async getToken(requestType, request) {\n    const result = await this.sendRequest(requestType, {\n      tokenParams: request\n    });\n    return {\n      token: BridgeProxy.validateBridgeResultOrThrow(result.token),\n      account: BridgeProxy.validateBridgeResultOrThrow(result.account)\n    };\n  }\n  async getActiveAccount() {\n    const result = await this.sendRequest(\"GetActiveAccount\");\n    return BridgeProxy.validateBridgeResultOrThrow(result.account);\n  }\n  getHostCapabilities() {\n    return this.capabilities ?? null;\n  }\n  /**\r\n   * A method used to send a request to the bridge\r\n   * @param request A token request\r\n   * @returns a promise that resolves to a response of provided type or rejects with a BridgeError\r\n   */\n  sendRequest(method, requestParams) {\n    const message = {\n      messageType: \"NestedAppAuthRequest\",\n      method: method,\n      requestId: BridgeProxy.getRandomId(),\n      ...requestParams\n    };\n    const promise = new Promise((resolve, reject) => {\n      const request = {\n        requestId: message.requestId,\n        method: message.method,\n        resolve: resolve,\n        reject: reject\n      };\n      BridgeProxy.bridgeRequests.push(request);\n      window.nestedAppAuthBridge.postMessage(JSON.stringify(message));\n    });\n    return promise;\n  }\n  static validateBridgeResultOrThrow(input) {\n    if (input === undefined) {\n      const bridgeError = {\n        status: BridgeStatusCode.NestedAppAuthUnavailable\n      };\n      throw bridgeError;\n    }\n    return input;\n  }\n  /**\r\n   * Private constructor for BridgeProxy\r\n   * @param sdkName The name of the SDK being used to make requests on behalf of the app\r\n   * @param sdkVersion The version of the SDK being used to make requests on behalf of the app\r\n   * @param capabilities The capabilities of the bridge / SDK / platform broker\r\n   */\n  constructor(sdkName, sdkVersion, capabilities) {\n    this.sdkName = sdkName;\n    this.sdkVersion = sdkVersion;\n    this.capabilities = capabilities;\n  }\n  /**\r\n   * Factory method for creating an implementation of IBridgeProxy\r\n   * @returns A promise that resolves to a BridgeProxy implementation\r\n   */\n  static async create() {\n    const response = await BridgeProxy.initializeNestedAppAuthBridge();\n    return new BridgeProxy(response.sdkName, response.sdkVersion, response.capabilities);\n  }\n}\nBridgeProxy.bridgeRequests = [];\nexport { BridgeProxy, BridgeProxy as default };","map":{"version":3,"names":["BridgeProxy","initializeNestedAppAuthBridge","window","undefined","Error","nestedAppAuthBridge","crypto","addEventListener","response","responsePayload","data","responseEnvelope","JSON","parse","request","bridgeRequests","find","element","requestId","splice","indexOf","success","resolve","reject","error","bridgeResponse","Promise","message","messageType","method","getRandomId","push","postMessage","stringify","validateBridgeResultOrThrow","initContext","console","log","randomUUID","getTokenInteractive","getToken","getTokenSilent","requestType","result","sendRequest","tokenParams","token","account","getActiveAccount","getHostCapabilities","capabilities","requestParams","promise","input","bridgeError","status","BridgeStatusCode","NestedAppAuthUnavailable","constructor","sdkName","sdkVersion","create"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-browser\\src\\naa\\BridgeProxy.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountInfo } from \"./AccountInfo\";\r\nimport { AuthBridge, AuthBridgeResponse } from \"./AuthBridge\";\r\nimport { AuthResult } from \"./AuthResult\";\r\nimport { BridgeCapabilities } from \"./BridgeCapabilities\";\r\nimport { BridgeError } from \"./BridgeError\";\r\nimport { BridgeRequest } from \"./BridgeRequest\";\r\nimport { BridgeRequestEnvelope, BridgeMethods } from \"./BridgeRequestEnvelope\";\r\nimport { BridgeResponseEnvelope } from \"./BridgeResponseEnvelope\";\r\nimport { BridgeStatusCode } from \"./BridgeStatusCode\";\r\nimport { IBridgeProxy } from \"./IBridgeProxy\";\r\nimport { InitContext } from \"./InitContext\";\r\nimport { TokenRequest } from \"./TokenRequest\";\r\n\r\ndeclare global {\r\n    interface Window {\r\n        nestedAppAuthBridge: AuthBridge;\r\n    }\r\n}\r\n\r\n/**\r\n * BridgeProxy\r\n * Provides a proxy for accessing a bridge to a host app and/or\r\n * platform broker\r\n */\r\nexport class BridgeProxy implements IBridgeProxy {\r\n    static bridgeRequests: BridgeRequest[] = [];\r\n    static crypto: Crypto;\r\n    sdkName: string;\r\n    sdkVersion: string;\r\n    capabilities?: BridgeCapabilities;\r\n\r\n    /**\r\n     * initializeNestedAppAuthBridge - Initializes the bridge to the host app\r\n     * @returns a promise that resolves to an InitializeBridgeResponse or rejects with an Error\r\n     * @remarks This method will be called by the create factory method\r\n     * @remarks If the bridge is not available, this method will throw an error\r\n     */\r\n    protected static async initializeNestedAppAuthBridge(): Promise<InitContext> {\r\n        if (window === undefined) {\r\n            throw new Error(\"window is undefined\");\r\n        }\r\n        if (window.nestedAppAuthBridge === undefined) {\r\n            throw new Error(\"window.nestedAppAuthBridge is undefined\");\r\n        }\r\n        if (window.crypto === undefined) {\r\n            throw new Error(\"window.crypto is undefined\");\r\n        }\r\n\r\n        try {\r\n            BridgeProxy.crypto = window.crypto;\r\n\r\n            window.nestedAppAuthBridge.addEventListener(\r\n                \"message\",\r\n                (response: AuthBridgeResponse) => {\r\n                    const responsePayload =\r\n                        typeof response === \"string\" ? response : response.data;\r\n                    const responseEnvelope: BridgeResponseEnvelope =\r\n                        JSON.parse(responsePayload);\r\n                    const request = BridgeProxy.bridgeRequests.find(\r\n                        (element) =>\r\n                            element.requestId === responseEnvelope.requestId\r\n                    );\r\n                    if (request !== undefined) {\r\n                        BridgeProxy.bridgeRequests.splice(\r\n                            BridgeProxy.bridgeRequests.indexOf(request),\r\n                            1\r\n                        );\r\n                        if (responseEnvelope.success) {\r\n                            request.resolve(responseEnvelope);\r\n                        } else {\r\n                            request.reject(responseEnvelope.error);\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n\r\n            const bridgeResponse = await new Promise<BridgeResponseEnvelope>(\r\n                (resolve, reject) => {\r\n                    const message: BridgeRequestEnvelope = {\r\n                        messageType: \"NestedAppAuthRequest\",\r\n                        method: \"GetInitContext\",\r\n                        requestId: BridgeProxy.getRandomId(),\r\n                    };\r\n                    const request: BridgeRequest = {\r\n                        requestId: message.requestId,\r\n                        method: message.method,\r\n                        resolve: resolve,\r\n                        reject: reject,\r\n                    };\r\n                    BridgeProxy.bridgeRequests.push(request);\r\n                    window.nestedAppAuthBridge.postMessage(\r\n                        JSON.stringify(message)\r\n                    );\r\n                }\r\n            );\r\n\r\n            return BridgeProxy.validateBridgeResultOrThrow(\r\n                bridgeResponse.initContext\r\n            );\r\n        } catch (error) {\r\n            window.console.log(error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    public static getRandomId(): string {\r\n        return BridgeProxy.crypto.randomUUID();\r\n    }\r\n\r\n    /**\r\n     * getTokenInteractive - Attempts to get a token interactively from the bridge\r\n     * @param request A token request\r\n     * @returns a promise that resolves to an auth result or rejects with a BridgeError\r\n     */\r\n    public getTokenInteractive(request: TokenRequest): Promise<AuthResult> {\r\n        return this.getToken(\"GetTokenPopup\", request);\r\n    }\r\n\r\n    /**\r\n     * getTokenSilent Attempts to get a token silently from the bridge\r\n     * @param request A token request\r\n     * @returns a promise that resolves to an auth result or rejects with a BridgeError\r\n     */\r\n    public getTokenSilent(request: TokenRequest): Promise<AuthResult> {\r\n        return this.getToken(\"GetToken\", request);\r\n    }\r\n\r\n    private async getToken(\r\n        requestType: BridgeMethods,\r\n        request: TokenRequest\r\n    ): Promise<AuthResult> {\r\n        const result = await this.sendRequest(requestType, {\r\n            tokenParams: request,\r\n        });\r\n        return {\r\n            token: BridgeProxy.validateBridgeResultOrThrow(result.token),\r\n            account: BridgeProxy.validateBridgeResultOrThrow(result.account),\r\n        };\r\n    }\r\n\r\n    public async getActiveAccount(): Promise<AccountInfo> {\r\n        const result = await this.sendRequest(\"GetActiveAccount\");\r\n        return BridgeProxy.validateBridgeResultOrThrow(result.account);\r\n    }\r\n\r\n    public getHostCapabilities(): BridgeCapabilities | null {\r\n        return this.capabilities ?? null;\r\n    }\r\n\r\n    /**\r\n     * A method used to send a request to the bridge\r\n     * @param request A token request\r\n     * @returns a promise that resolves to a response of provided type or rejects with a BridgeError\r\n     */\r\n    private sendRequest(\r\n        method: BridgeMethods,\r\n        requestParams?: Partial<BridgeRequestEnvelope>\r\n    ): Promise<BridgeResponseEnvelope> {\r\n        const message: BridgeRequestEnvelope = {\r\n            messageType: \"NestedAppAuthRequest\",\r\n            method: method,\r\n            requestId: BridgeProxy.getRandomId(),\r\n            ...requestParams,\r\n        };\r\n\r\n        const promise = new Promise<BridgeResponseEnvelope>(\r\n            (resolve, reject) => {\r\n                const request: BridgeRequest = {\r\n                    requestId: message.requestId,\r\n                    method: message.method,\r\n                    resolve: resolve,\r\n                    reject: reject,\r\n                };\r\n                BridgeProxy.bridgeRequests.push(request);\r\n                window.nestedAppAuthBridge.postMessage(JSON.stringify(message));\r\n            }\r\n        );\r\n\r\n        return promise;\r\n    }\r\n\r\n    private static validateBridgeResultOrThrow<T>(input: T | undefined): T {\r\n        if (input === undefined) {\r\n            const bridgeError: BridgeError = {\r\n                status: BridgeStatusCode.NestedAppAuthUnavailable,\r\n            };\r\n            throw bridgeError;\r\n        }\r\n        return input;\r\n    }\r\n\r\n    /**\r\n     * Private constructor for BridgeProxy\r\n     * @param sdkName The name of the SDK being used to make requests on behalf of the app\r\n     * @param sdkVersion The version of the SDK being used to make requests on behalf of the app\r\n     * @param capabilities The capabilities of the bridge / SDK / platform broker\r\n     */\r\n    private constructor(\r\n        sdkName: string,\r\n        sdkVersion: string,\r\n        capabilities?: BridgeCapabilities\r\n    ) {\r\n        this.sdkName = sdkName;\r\n        this.sdkVersion = sdkVersion;\r\n        this.capabilities = capabilities;\r\n    }\r\n\r\n    /**\r\n     * Factory method for creating an implementation of IBridgeProxy\r\n     * @returns A promise that resolves to a BridgeProxy implementation\r\n     */\r\n    public static async create(): Promise<IBridgeProxy> {\r\n        const response = await BridgeProxy.initializeNestedAppAuthBridge();\r\n        return new BridgeProxy(\r\n            response.sdkName,\r\n            response.sdkVersion,\r\n            response.capabilities\r\n        );\r\n    }\r\n}\r\n\r\nexport default BridgeProxy;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}