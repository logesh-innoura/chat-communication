{"ast":null,"code":"/*! @azure/msal-common v14.6.0 2024-01-09 */\n'use strict';\n\nimport { Separators, CacheAccountType } from '../../utils/Constants.mjs';\nimport { buildClientInfo } from '../../account/ClientInfo.mjs';\nimport { buildTenantProfileFromIdTokenClaims } from '../../account/AccountInfo.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { AuthorityType } from '../../authority/AuthorityType.mjs';\nimport { getTenantIdFromIdTokenClaims } from '../../account/TokenClaims.mjs';\nimport { ProtocolMode } from '../../authority/ProtocolMode.mjs';\nimport { invalidCacheEnvironment } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      nativeAccountId: Account identifier on the native device\r\n *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser\r\n * }\r\n * @internal\r\n */\nclass AccountEntity {\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n  generateAccountId() {\n    const accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\r\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n   */\n  generateAccountKey() {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  }\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n  getAccountInfo() {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      nativeAccountId: this.nativeAccountId,\n      authorityType: this.authorityType,\n      // Deserialize tenant profiles array into a Map\n      tenantProfiles: new Map((this.tenantProfiles || []).map(tenantProfile => {\n        return [tenantProfile.tenantId, tenantProfile];\n      }))\n    };\n  }\n  /**\r\n   * Returns true if the account entity is in single tenant format (outdated), false otherwise\r\n   */\n  isSingleTenant() {\n    return !this.tenantProfiles;\n  }\n  /**\r\n   * Generates account key from interface\r\n   * @param accountInterface\r\n   */\n  static generateAccountCacheKey(accountInterface) {\n    const homeTenantId = accountInterface.homeAccountId.split(\".\")[1];\n    const accountKey = [accountInterface.homeAccountId, accountInterface.environment || \"\", homeTenantId || accountInterface.tenantId || \"\"];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\r\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n   * @param accountDetails\r\n   */\n  static createAccount(accountDetails, authority, base64Decode) {\n    const account = new AccountEntity();\n    if (authority.authorityType === AuthorityType.Adfs) {\n      account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n    } else if (authority.protocolMode === ProtocolMode.AAD) {\n      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    } else {\n      account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    }\n    let clientInfo;\n    if (accountDetails.clientInfo && base64Decode) {\n      clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);\n    }\n    account.clientInfo = accountDetails.clientInfo;\n    account.homeAccountId = accountDetails.homeAccountId;\n    account.nativeAccountId = accountDetails.nativeAccountId;\n    const env = accountDetails.environment || authority && authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    account.environment = env;\n    // non AAD scenarios can have empty realm\n    account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || \"\";\n    // How do you account for MSA CID here?\n    account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims.oid || accountDetails.idTokenClaims.sub || \"\";\n    /*\r\n     * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n     * In most cases it will contain a single email. This field should not be relied upon if a custom\r\n     * policy is configured to return more than 1 email.\r\n     */\n    const preferredUsername = accountDetails.idTokenClaims.preferred_username || accountDetails.idTokenClaims.upn;\n    const email = accountDetails.idTokenClaims.emails ? accountDetails.idTokenClaims.emails[0] : null;\n    account.username = preferredUsername || email || \"\";\n    account.name = accountDetails.idTokenClaims.name;\n    account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n    account.msGraphHost = accountDetails.msGraphHost;\n    if (accountDetails.tenantProfiles) {\n      account.tenantProfiles = accountDetails.tenantProfiles;\n    } else {\n      const tenantProfiles = [];\n      if (accountDetails.idTokenClaims) {\n        const tenantProfile = buildTenantProfileFromIdTokenClaims(accountDetails.homeAccountId, accountDetails.idTokenClaims);\n        tenantProfiles.push(tenantProfile);\n      }\n      account.tenantProfiles = tenantProfiles;\n    }\n    return account;\n  }\n  /**\r\n   * Creates an AccountEntity object from AccountInfo\r\n   * @param accountInfo\r\n   * @param cloudGraphHostName\r\n   * @param msGraphHost\r\n   * @returns\r\n   */\n  static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {\n    const account = new AccountEntity();\n    account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = accountInfo.homeAccountId;\n    account.localAccountId = accountInfo.localAccountId;\n    account.nativeAccountId = accountInfo.nativeAccountId;\n    account.realm = accountInfo.tenantId;\n    account.environment = accountInfo.environment;\n    account.username = accountInfo.username;\n    account.name = accountInfo.name;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    // Serialize tenant profiles map into an array\n    account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);\n    return account;\n  }\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n  static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {\n    // since ADFS/DSTS do not have tid and does not set client_info\n    if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {\n      // for cases where there is clientInfo\n      if (serverClientInfo) {\n        try {\n          const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);\n          if (clientInfo.uid && clientInfo.utid) {\n            return `${clientInfo.uid}.${clientInfo.utid}`;\n          }\n        } catch (e) {}\n      }\n      logger.warning(\"No client info in response\");\n    }\n    // default to \"sub\" claim\n    return idTokenClaims?.sub || \"\";\n  }\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n  static isAccountEntity(entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  }\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n  static accountInfoIsEqual(accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n    let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n    if (compareClaims) {\n      const accountAClaims = accountA.idTokenClaims || {};\n      const accountBClaims = accountB.idTokenClaims || {};\n      // issued at timestamp and nonce are expected to change each time a new id token is acquired\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  }\n}\nexport { AccountEntity };","map":{"version":3,"names":["AccountEntity","generateAccountId","accountId","homeAccountId","environment","join","Separators","CACHE_KEY_SEPARATOR","toLowerCase","generateAccountKey","generateAccountCacheKey","tenantId","realm","username","localAccountId","getAccountInfo","name","nativeAccountId","authorityType","tenantProfiles","Map","map","tenantProfile","isSingleTenant","accountInterface","homeTenantId","split","accountKey","createAccount","accountDetails","authority","base64Decode","account","AuthorityType","Adfs","CacheAccountType","ADFS_ACCOUNT_TYPE","protocolMode","ProtocolMode","AAD","MSSTS_ACCOUNT_TYPE","GENERIC_ACCOUNT_TYPE","clientInfo","buildClientInfo","env","getPreferredCache","createClientAuthError","invalidCacheEnvironment","utid","getTenantIdFromIdTokenClaims","idTokenClaims","uid","oid","sub","preferredUsername","preferred_username","upn","email","emails","cloudGraphHostName","msGraphHost","buildTenantProfileFromIdTokenClaims","push","createFromAccountInfo","accountInfo","Array","from","values","generateHomeAccountId","serverClientInfo","authType","logger","cryptoObj","Dsts","e","warning","isAccountEntity","entity","hasOwnProperty","accountInfoIsEqual","accountA","accountB","compareClaims","claimsMatch","accountAClaims","accountBClaims","iat","nonce"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-common\\src\\cache\\entities\\AccountEntity.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { CacheAccountType, Separators } from \"../../utils/Constants\";\r\nimport { Authority } from \"../../authority/Authority\";\r\nimport { ICrypto } from \"../../crypto/ICrypto\";\r\nimport { ClientInfo, buildClientInfo } from \"../../account/ClientInfo\";\r\nimport {\r\n    AccountInfo,\r\n    TenantProfile,\r\n    buildTenantProfileFromIdTokenClaims,\r\n} from \"../../account/AccountInfo\";\r\nimport {\r\n    createClientAuthError,\r\n    ClientAuthErrorCodes,\r\n} from \"../../error/ClientAuthError\";\r\nimport { AuthorityType } from \"../../authority/AuthorityType\";\r\nimport { Logger } from \"../../logger/Logger\";\r\nimport {\r\n    TokenClaims,\r\n    getTenantIdFromIdTokenClaims,\r\n} from \"../../account/TokenClaims\";\r\nimport { ProtocolMode } from \"../../authority/ProtocolMode\";\r\n\r\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      nativeAccountId: Account identifier on the native device\r\n *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser\r\n * }\r\n * @internal\r\n */\r\nexport class AccountEntity {\r\n    homeAccountId: string;\r\n    environment: string;\r\n    realm: string;\r\n    localAccountId: string;\r\n    username: string;\r\n    authorityType: string;\r\n    clientInfo?: string;\r\n    name?: string;\r\n    lastModificationTime?: string;\r\n    lastModificationApp?: string;\r\n    cloudGraphHostName?: string;\r\n    msGraphHost?: string;\r\n    nativeAccountId?: string;\r\n    tenantProfiles?: Array<TenantProfile>;\r\n\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId(): string {\r\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAccountKey(): string {\r\n        return AccountEntity.generateAccountCacheKey({\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the AccountInfo interface for this account.\r\n     */\r\n    getAccountInfo(): AccountInfo {\r\n        return {\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n            name: this.name,\r\n            nativeAccountId: this.nativeAccountId,\r\n            authorityType: this.authorityType,\r\n            // Deserialize tenant profiles array into a Map\r\n            tenantProfiles: new Map(\r\n                (this.tenantProfiles || []).map((tenantProfile) => {\r\n                    return [tenantProfile.tenantId, tenantProfile];\r\n                })\r\n            ),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns true if the account entity is in single tenant format (outdated), false otherwise\r\n     */\r\n    isSingleTenant(): boolean {\r\n        return !this.tenantProfiles;\r\n    }\r\n\r\n    /**\r\n     * Generates account key from interface\r\n     * @param accountInterface\r\n     */\r\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\r\n        const homeTenantId = accountInterface.homeAccountId.split(\".\")[1];\r\n        const accountKey = [\r\n            accountInterface.homeAccountId,\r\n            accountInterface.environment || \"\",\r\n            homeTenantId || accountInterface.tenantId || \"\",\r\n        ];\r\n\r\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n     * @param accountDetails\r\n     */\r\n    static createAccount(\r\n        accountDetails: {\r\n            homeAccountId: string;\r\n            idTokenClaims: TokenClaims;\r\n            clientInfo?: string;\r\n            cloudGraphHostName?: string;\r\n            msGraphHost?: string;\r\n            environment?: string;\r\n            nativeAccountId?: string;\r\n            tenantProfiles?: Array<TenantProfile>;\r\n        },\r\n        authority: Authority,\r\n        base64Decode?: (input: string) => string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        if (authority.authorityType === AuthorityType.Adfs) {\r\n            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\r\n        } else if (authority.protocolMode === ProtocolMode.AAD) {\r\n            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\r\n        } else {\r\n            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        }\r\n\r\n        let clientInfo: ClientInfo | undefined;\r\n\r\n        if (accountDetails.clientInfo && base64Decode) {\r\n            clientInfo = buildClientInfo(\r\n                accountDetails.clientInfo,\r\n                base64Decode\r\n            );\r\n        }\r\n\r\n        account.clientInfo = accountDetails.clientInfo;\r\n        account.homeAccountId = accountDetails.homeAccountId;\r\n        account.nativeAccountId = accountDetails.nativeAccountId;\r\n\r\n        const env =\r\n            accountDetails.environment ||\r\n            (authority && authority.getPreferredCache());\r\n\r\n        if (!env) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.invalidCacheEnvironment\r\n            );\r\n        }\r\n\r\n        account.environment = env;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm =\r\n            clientInfo?.utid ||\r\n            getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) ||\r\n            \"\";\r\n\r\n        // How do you account for MSA CID here?\r\n        account.localAccountId =\r\n            clientInfo?.uid ||\r\n            accountDetails.idTokenClaims.oid ||\r\n            accountDetails.idTokenClaims.sub ||\r\n            \"\";\r\n\r\n        /*\r\n         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n         * In most cases it will contain a single email. This field should not be relied upon if a custom\r\n         * policy is configured to return more than 1 email.\r\n         */\r\n        const preferredUsername =\r\n            accountDetails.idTokenClaims.preferred_username ||\r\n            accountDetails.idTokenClaims.upn;\r\n        const email = accountDetails.idTokenClaims.emails\r\n            ? accountDetails.idTokenClaims.emails[0]\r\n            : null;\r\n\r\n        account.username = preferredUsername || email || \"\";\r\n        account.name = accountDetails.idTokenClaims.name;\r\n\r\n        account.cloudGraphHostName = accountDetails.cloudGraphHostName;\r\n        account.msGraphHost = accountDetails.msGraphHost;\r\n\r\n        if (accountDetails.tenantProfiles) {\r\n            account.tenantProfiles = accountDetails.tenantProfiles;\r\n        } else {\r\n            const tenantProfiles = [];\r\n            if (accountDetails.idTokenClaims) {\r\n                const tenantProfile = buildTenantProfileFromIdTokenClaims(\r\n                    accountDetails.homeAccountId,\r\n                    accountDetails.idTokenClaims\r\n                );\r\n                tenantProfiles.push(tenantProfile);\r\n            }\r\n            account.tenantProfiles = tenantProfiles;\r\n        }\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Creates an AccountEntity object from AccountInfo\r\n     * @param accountInfo\r\n     * @param cloudGraphHostName\r\n     * @param msGraphHost\r\n     * @returns\r\n     */\r\n    static createFromAccountInfo(\r\n        accountInfo: AccountInfo,\r\n        cloudGraphHostName?: string,\r\n        msGraphHost?: string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType =\r\n            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        account.homeAccountId = accountInfo.homeAccountId;\r\n        account.localAccountId = accountInfo.localAccountId;\r\n        account.nativeAccountId = accountInfo.nativeAccountId;\r\n\r\n        account.realm = accountInfo.tenantId;\r\n        account.environment = accountInfo.environment;\r\n\r\n        account.username = accountInfo.username;\r\n        account.name = accountInfo.name;\r\n\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n        // Serialize tenant profiles map into an array\r\n        account.tenantProfiles = Array.from(\r\n            accountInfo.tenantProfiles?.values() || []\r\n        );\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Generate HomeAccountId from server response\r\n     * @param serverClientInfo\r\n     * @param authType\r\n     */\r\n    static generateHomeAccountId(\r\n        serverClientInfo: string,\r\n        authType: AuthorityType,\r\n        logger: Logger,\r\n        cryptoObj: ICrypto,\r\n        idTokenClaims?: TokenClaims\r\n    ): string {\r\n        // since ADFS/DSTS do not have tid and does not set client_info\r\n        if (\r\n            !(\r\n                authType === AuthorityType.Adfs ||\r\n                authType === AuthorityType.Dsts\r\n            )\r\n        ) {\r\n            // for cases where there is clientInfo\r\n            if (serverClientInfo) {\r\n                try {\r\n                    const clientInfo = buildClientInfo(\r\n                        serverClientInfo,\r\n                        cryptoObj.base64Decode\r\n                    );\r\n                    if (clientInfo.uid && clientInfo.utid) {\r\n                        return `${clientInfo.uid}.${clientInfo.utid}`;\r\n                    }\r\n                } catch (e) {}\r\n            }\r\n            logger.warning(\"No client info in response\");\r\n        }\r\n\r\n        // default to \"sub\" claim\r\n        return idTokenClaims?.sub || \"\";\r\n    }\r\n\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    static isAccountEntity(entity: object): boolean {\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            entity.hasOwnProperty(\"homeAccountId\") &&\r\n            entity.hasOwnProperty(\"environment\") &&\r\n            entity.hasOwnProperty(\"realm\") &&\r\n            entity.hasOwnProperty(\"localAccountId\") &&\r\n            entity.hasOwnProperty(\"username\") &&\r\n            entity.hasOwnProperty(\"authorityType\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Helper function to determine whether 2 accountInfo objects represent the same account\r\n     * @param accountA\r\n     * @param accountB\r\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n     */\r\n    static accountInfoIsEqual(\r\n        accountA: AccountInfo | null,\r\n        accountB: AccountInfo | null,\r\n        compareClaims?: boolean\r\n    ): boolean {\r\n        if (!accountA || !accountB) {\r\n            return false;\r\n        }\r\n\r\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\r\n        if (compareClaims) {\r\n            const accountAClaims = (accountA.idTokenClaims ||\r\n                {}) as TokenClaims;\r\n            const accountBClaims = (accountB.idTokenClaims ||\r\n                {}) as TokenClaims;\r\n\r\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\r\n            claimsMatch =\r\n                accountAClaims.iat === accountBClaims.iat &&\r\n                accountAClaims.nonce === accountBClaims.nonce;\r\n        }\r\n\r\n        return (\r\n            accountA.homeAccountId === accountB.homeAccountId &&\r\n            accountA.localAccountId === accountB.localAccountId &&\r\n            accountA.username === accountB.username &&\r\n            accountA.tenantId === accountB.tenantId &&\r\n            accountA.environment === accountB.environment &&\r\n            accountA.nativeAccountId === accountB.nativeAccountId &&\r\n            claimsMatch\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}