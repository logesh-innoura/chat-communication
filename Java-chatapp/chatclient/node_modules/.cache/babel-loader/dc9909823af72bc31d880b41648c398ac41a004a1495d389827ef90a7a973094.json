{"ast":null,"code":"/*! @azure/msal-common v14.6.0 2024-01-09 */\n'use strict';\n\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { AADAuthorityConstants, Constants } from '../utils/Constants.mjs';\nimport { getDeserializedResponse } from '../utils/UrlUtils.mjs';\nimport { urlEmptyError, urlParseError, authorityUriInsecure } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\nclass UrlString {\n  get urlString() {\n    return this._urlString;\n  }\n  constructor(url) {\n    this._urlString = url;\n    if (!this._urlString) {\n      // Throws error if url is empty\n      throw createClientConfigurationError(urlEmptyError);\n    }\n    if (!url.includes(\"#\")) {\n      this._urlString = UrlString.canonicalizeUri(url);\n    }\n  }\n  /**\r\n   * Ensure urls are lower case and end with a / character.\r\n   * @param url\r\n   */\n  static canonicalizeUri(url) {\n    if (url) {\n      let lowerCaseUrl = url.toLowerCase();\n      if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n      } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n      }\n      if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n      return lowerCaseUrl;\n    }\n    return url;\n  }\n  /**\r\n   * Throws if urlString passed is not a valid authority URI string.\r\n   */\n  validateAsUri() {\n    // Attempts to parse url for uri components\n    let components;\n    try {\n      components = this.getUrlComponents();\n    } catch (e) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    // Throw error if URI or path segments are not parseable.\n    if (!components.HostNameAndPort || !components.PathSegments) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    // Throw error if uri is insecure.\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\n      throw createClientConfigurationError(authorityUriInsecure);\n    }\n  }\n  /**\r\n   * Given a url and a query string return the url with provided query string appended\r\n   * @param url\r\n   * @param queryString\r\n   */\n  static appendQueryString(url, queryString) {\n    if (!queryString) {\n      return url;\n    }\n    return url.indexOf(\"?\") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;\n  }\n  /**\r\n   * Returns a url with the hash removed\r\n   * @param url\r\n   */\n  static removeHashFromUrl(url) {\n    return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n  }\n  /**\r\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n   * @param href The url\r\n   * @param tenantId The tenant id to replace\r\n   */\n  replaceTenantPath(tenantId) {\n    const urlObject = this.getUrlComponents();\n    const pathArray = urlObject.PathSegments;\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n    return UrlString.constructAuthorityUriFromObject(urlObject);\n  }\n  /**\r\n   * Parses out the components from a url string.\r\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n   */\n  getUrlComponents() {\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n    const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    // If url string does not match regEx, we throw an error\n    const match = this.urlString.match(regEx);\n    if (!match) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    // Url component object\n    const urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5],\n      QueryString: match[7]\n    };\n    let pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(val => val && val.length > 0); // remove empty elements\n    urlComponents.PathSegments = pathSegments;\n    if (urlComponents.QueryString && urlComponents.QueryString.endsWith(\"/\")) {\n      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n    }\n    return urlComponents;\n  }\n  static getDomainFromUrl(url) {\n    const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n    const match = url.match(regEx);\n    if (!match) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    return match[2];\n  }\n  static getAbsoluteUrl(relativeUrl, baseUrl) {\n    if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n      const url = new UrlString(baseUrl);\n      const baseComponents = url.getUrlComponents();\n      return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\n    }\n    return relativeUrl;\n  }\n  static constructAuthorityUriFromObject(urlObject) {\n    return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\n  }\n  /**\r\n   * Check if the hash of the URL string contains known properties\r\n   * @deprecated This API will be removed in a future version\r\n   */\n  static hashContainsKnownProperties(response) {\n    return !!getDeserializedResponse(response);\n  }\n}\nexport { UrlString };","map":{"version":3,"names":["UrlString","urlString","_urlString","constructor","url","createClientConfigurationError","urlEmptyError","includes","canonicalizeUri","lowerCaseUrl","toLowerCase","StringUtils","endsWith","slice","validateAsUri","components","getUrlComponents","e","urlParseError","HostNameAndPort","PathSegments","Protocol","authorityUriInsecure","appendQueryString","queryString","indexOf","removeHashFromUrl","split","replaceTenantPath","tenantId","urlObject","pathArray","length","AADAuthorityConstants","COMMON","ORGANIZATIONS","constructAuthorityUriFromObject","regEx","RegExp","match","urlComponents","AbsolutePath","QueryString","pathSegments","filter","val","substring","getDomainFromUrl","getAbsoluteUrl","relativeUrl","baseUrl","Constants","FORWARD_SLASH","baseComponents","join","hashContainsKnownProperties","response","getDeserializedResponse"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-common\\src\\url\\UrlString.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    createClientConfigurationError,\r\n    ClientConfigurationErrorCodes,\r\n} from \"../error/ClientConfigurationError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { IUri } from \"./IUri\";\r\nimport { AADAuthorityConstants, Constants } from \"../utils/Constants\";\r\nimport * as UrlUtils from \"../utils/UrlUtils\";\r\n\r\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\r\nexport class UrlString {\r\n    // internal url string field\r\n    private _urlString: string;\r\n    public get urlString(): string {\r\n        return this._urlString;\r\n    }\r\n\r\n    constructor(url: string) {\r\n        this._urlString = url;\r\n        if (!this._urlString) {\r\n            // Throws error if url is empty\r\n            throw createClientConfigurationError(\r\n                ClientConfigurationErrorCodes.urlEmptyError\r\n            );\r\n        }\r\n\r\n        if (!url.includes(\"#\")) {\r\n            this._urlString = UrlString.canonicalizeUri(url);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure urls are lower case and end with a / character.\r\n     * @param url\r\n     */\r\n    static canonicalizeUri(url: string): string {\r\n        if (url) {\r\n            let lowerCaseUrl = url.toLowerCase();\r\n\r\n            if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -1);\r\n            } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -2);\r\n            }\r\n\r\n            if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\r\n                lowerCaseUrl += \"/\";\r\n            }\r\n\r\n            return lowerCaseUrl;\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Throws if urlString passed is not a valid authority URI string.\r\n     */\r\n    validateAsUri(): void {\r\n        // Attempts to parse url for uri components\r\n        let components;\r\n        try {\r\n            components = this.getUrlComponents();\r\n        } catch (e) {\r\n            throw createClientConfigurationError(\r\n                ClientConfigurationErrorCodes.urlParseError\r\n            );\r\n        }\r\n\r\n        // Throw error if URI or path segments are not parseable.\r\n        if (!components.HostNameAndPort || !components.PathSegments) {\r\n            throw createClientConfigurationError(\r\n                ClientConfigurationErrorCodes.urlParseError\r\n            );\r\n        }\r\n\r\n        // Throw error if uri is insecure.\r\n        if (\r\n            !components.Protocol ||\r\n            components.Protocol.toLowerCase() !== \"https:\"\r\n        ) {\r\n            throw createClientConfigurationError(\r\n                ClientConfigurationErrorCodes.authorityUriInsecure\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a url and a query string return the url with provided query string appended\r\n     * @param url\r\n     * @param queryString\r\n     */\r\n    static appendQueryString(url: string, queryString: string): string {\r\n        if (!queryString) {\r\n            return url;\r\n        }\r\n\r\n        return url.indexOf(\"?\") < 0\r\n            ? `${url}?${queryString}`\r\n            : `${url}&${queryString}`;\r\n    }\r\n\r\n    /**\r\n     * Returns a url with the hash removed\r\n     * @param url\r\n     */\r\n    static removeHashFromUrl(url: string): string {\r\n        return UrlString.canonicalizeUri(url.split(\"#\")[0]);\r\n    }\r\n\r\n    /**\r\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n     * @param href The url\r\n     * @param tenantId The tenant id to replace\r\n     */\r\n    replaceTenantPath(tenantId: string): UrlString {\r\n        const urlObject = this.getUrlComponents();\r\n        const pathArray = urlObject.PathSegments;\r\n        if (\r\n            tenantId &&\r\n            pathArray.length !== 0 &&\r\n            (pathArray[0] === AADAuthorityConstants.COMMON ||\r\n                pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)\r\n        ) {\r\n            pathArray[0] = tenantId;\r\n        }\r\n        return UrlString.constructAuthorityUriFromObject(urlObject);\r\n    }\r\n\r\n    /**\r\n     * Parses out the components from a url string.\r\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n     */\r\n    getUrlComponents(): IUri {\r\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\r\n        const regEx = RegExp(\r\n            \"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\"\r\n        );\r\n\r\n        // If url string does not match regEx, we throw an error\r\n        const match = this.urlString.match(regEx);\r\n        if (!match) {\r\n            throw createClientConfigurationError(\r\n                ClientConfigurationErrorCodes.urlParseError\r\n            );\r\n        }\r\n\r\n        // Url component object\r\n        const urlComponents = {\r\n            Protocol: match[1],\r\n            HostNameAndPort: match[4],\r\n            AbsolutePath: match[5],\r\n            QueryString: match[7],\r\n        } as IUri;\r\n\r\n        let pathSegments = urlComponents.AbsolutePath.split(\"/\");\r\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\r\n        urlComponents.PathSegments = pathSegments;\r\n\r\n        if (\r\n            urlComponents.QueryString &&\r\n            urlComponents.QueryString.endsWith(\"/\")\r\n        ) {\r\n            urlComponents.QueryString = urlComponents.QueryString.substring(\r\n                0,\r\n                urlComponents.QueryString.length - 1\r\n            );\r\n        }\r\n        return urlComponents;\r\n    }\r\n\r\n    static getDomainFromUrl(url: string): string {\r\n        const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\r\n\r\n        const match = url.match(regEx);\r\n\r\n        if (!match) {\r\n            throw createClientConfigurationError(\r\n                ClientConfigurationErrorCodes.urlParseError\r\n            );\r\n        }\r\n\r\n        return match[2];\r\n    }\r\n\r\n    static getAbsoluteUrl(relativeUrl: string, baseUrl: string): string {\r\n        if (relativeUrl[0] === Constants.FORWARD_SLASH) {\r\n            const url = new UrlString(baseUrl);\r\n            const baseComponents = url.getUrlComponents();\r\n\r\n            return (\r\n                baseComponents.Protocol +\r\n                \"//\" +\r\n                baseComponents.HostNameAndPort +\r\n                relativeUrl\r\n            );\r\n        }\r\n\r\n        return relativeUrl;\r\n    }\r\n\r\n    static constructAuthorityUriFromObject(urlObject: IUri): UrlString {\r\n        return new UrlString(\r\n            urlObject.Protocol +\r\n                \"//\" +\r\n                urlObject.HostNameAndPort +\r\n                \"/\" +\r\n                urlObject.PathSegments.join(\"/\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the hash of the URL string contains known properties\r\n     * @deprecated This API will be removed in a future version\r\n     */\r\n    static hashContainsKnownProperties(response: string): boolean {\r\n        return !!UrlUtils.getDeserializedResponse(response);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}