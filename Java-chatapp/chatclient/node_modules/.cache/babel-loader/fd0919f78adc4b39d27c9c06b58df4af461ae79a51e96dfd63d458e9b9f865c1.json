{"ast":null,"code":"/*! @azure/msal-common v14.6.0 2024-01-09 */\n'use strict';\n\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from '../cache/entities/AccountEntity.mjs';\nimport { isInteractionRequiredError, InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { CacheRecord } from '../cache/entities/CacheRecord.mjs';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.mjs';\nimport { HttpStatus, Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\nimport { getTenantIdFromIdTokenClaims } from '../account/TokenClaims.mjs';\nimport { updateAccountTenantProfileData, buildTenantProfileFromIdTokenClaims } from '../account/AccountInfo.mjs';\nimport { createAccessTokenEntity, createRefreshTokenEntity, createIdTokenEntity } from '../cache/utils/CacheHelpers.mjs';\nimport { stateNotFound, invalidState, stateMismatch, nonceMismatch, authTimeNotFound, invalidCacheEnvironment, keyIdMissing } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Class that handles response parsing.\r\n * @internal\r\n */\nclass ResponseHandler {\n  constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param requestState\r\n   * @param cryptoObj\r\n   */\n  validateServerAuthorizationCodeResponse(serverResponse, requestState) {\n    if (!serverResponse.state || !requestState) {\n      throw serverResponse.state ? createClientAuthError(stateNotFound, \"Cached State\") : createClientAuthError(stateNotFound, \"Server State\");\n    }\n    let decodedServerResponseState;\n    let decodedRequestState;\n    try {\n      decodedServerResponseState = decodeURIComponent(serverResponse.state);\n    } catch (e) {\n      throw createClientAuthError(invalidState, serverResponse.state);\n    }\n    try {\n      decodedRequestState = decodeURIComponent(requestState);\n    } catch (e) {\n      throw createClientAuthError(invalidState, serverResponse.state);\n    }\n    if (decodedServerResponseState !== decodedRequestState) {\n      throw createClientAuthError(stateMismatch);\n    }\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error || \"\", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || \"\", serverResponse.trace_id || \"\", serverResponse.correlation_id || \"\", serverResponse.claims || \"\");\n      }\n      throw new ServerError(serverResponse.error || \"\", serverResponse.error_description, serverResponse.suberror);\n    }\n  }\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   * @param refreshAccessToken\r\n   */\n  validateTokenResponse(serverResponse, refreshAccessToken) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n      const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror);\n      // check if 500 error\n      if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n        // check if 400 error\n      } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n      }\n      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n      throw serverError;\n    }\n  }\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n  async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n    // create an idToken object (not entity)\n    let idTokenClaims;\n    if (serverTokenResponse.id_token) {\n      idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);\n      // token nonce check (TODO: Add a warning if no nonce is given?)\n      if (authCodePayload && authCodePayload.nonce) {\n        if (idTokenClaims.nonce !== authCodePayload.nonce) {\n          throw createClientAuthError(nonceMismatch);\n        }\n      }\n      // token max_age check\n      if (request.maxAge || request.maxAge === 0) {\n        const authTime = idTokenClaims.auth_time;\n        if (!authTime) {\n          throw createClientAuthError(authTimeNotFound);\n        }\n        checkMaxAge(authTime, request.maxAge);\n      }\n    }\n    // generate homeAccountId\n    this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n    // save the response tokens\n    let requestStateObj;\n    if (!!authCodePayload && !!authCodePayload.state) {\n      requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n    }\n    // Add keyId from request to serverTokenResponse if defined\n    serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n    const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\n    let cacheContext;\n    try {\n      if (this.persistencePlugin && this.serializableCache) {\n        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n        cacheContext = new TokenCacheContext(this.serializableCache, true);\n        await this.persistencePlugin.beforeCacheAccess(cacheContext);\n      }\n      /*\r\n       * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n       * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n       * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n       * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n       */\n      if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n        const key = cacheRecord.account.generateAccountKey();\n        const account = this.cacheStorage.getAccount(key, this.logger);\n        if (!account) {\n          this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n          return await ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\n        }\n      }\n      await this.cacheStorage.saveCacheRecord(cacheRecord, request.storeInCache);\n    } finally {\n      if (this.persistencePlugin && this.serializableCache && cacheContext) {\n        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n        await this.persistencePlugin.afterCacheAccess(cacheContext);\n      }\n    }\n    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\n  }\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n  generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\n    const env = authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);\n    // IdToken: non AAD scenarios can have empty realm\n    let cachedIdToken;\n    let cachedAccount;\n    if (serverTokenResponse.id_token && !!idTokenClaims) {\n      cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || \"\");\n      cachedAccount = buildAccountToCache(this.cacheStorage, authority, this.homeAccountIdentifier, idTokenClaims, this.cryptoObj.base64Decode, serverTokenResponse.client_info, env, claimsTenantId, authCodePayload, undefined,\n      // nativeAccountId\n      this.logger);\n    }\n    // AccessToken\n    let cachedAccessToken = null;\n    if (serverTokenResponse.access_token) {\n      // If scopes not returned in server response, use request scopes\n      const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n      const expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      const refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      const tokenExpirationSeconds = reqTimestamp + expiresIn;\n      const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    let cachedRefreshToken = null;\n    if (serverTokenResponse.refresh_token) {\n      let rtExpiresOn;\n      if (serverTokenResponse.refresh_token_expires_in) {\n        const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === \"string\" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;\n        rtExpiresOn = reqTimestamp + rtExpiresIn;\n      }\n      cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);\n    }\n    // appMetadata\n    let cachedAppMetadata = null;\n    if (serverTokenResponse.foci) {\n      cachedAppMetadata = {\n        clientId: this.clientId,\n        environment: env,\n        familyId: serverTokenResponse.foci\n      };\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  }\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n  static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\n    let accessToken = Constants.EMPTY_STRING;\n    let responseScopes = [];\n    let expiresOn = null;\n    let extExpiresOn;\n    let refreshOn;\n    let familyId = Constants.EMPTY_STRING;\n    if (cacheRecord.accessToken) {\n      if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\n        const popTokenGenerator = new PopTokenGenerator(cryptoObj);\n        const {\n          secret,\n          keyId\n        } = cacheRecord.accessToken;\n        if (!keyId) {\n          throw createClientAuthError(keyIdMissing);\n        }\n        accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\n      } else {\n        accessToken = cacheRecord.accessToken.secret;\n      }\n      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n      expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n      extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n      if (cacheRecord.accessToken.refreshOn) {\n        refreshOn = new Date(Number(cacheRecord.accessToken.refreshOn) * 1000);\n      }\n    }\n    if (cacheRecord.appMetadata) {\n      familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : \"\";\n    }\n    const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n    const tid = idTokenClaims?.tid || \"\";\n    // for hybrid + native bridge enablement, send back the native account Id\n    if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n      cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\n    }\n    const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(cacheRecord.account.getAccountInfo(), undefined,\n    // tenantProfile optional\n    idTokenClaims) : null;\n    return {\n      authority: authority.canonicalAuthority,\n      uniqueId: uid,\n      tenantId: tid,\n      scopes: responseScopes,\n      account: accountInfo,\n      idToken: cacheRecord?.idToken?.secret || \"\",\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken,\n      fromCache: fromTokenCache,\n      expiresOn: expiresOn,\n      extExpiresOn: extExpiresOn,\n      refreshOn: refreshOn,\n      correlationId: request.correlationId,\n      requestId: requestId || Constants.EMPTY_STRING,\n      familyId: familyId,\n      tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n      state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n      cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\n      msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n      code: serverTokenResponse?.spa_code,\n      fromNativeBroker: false\n    };\n  }\n}\nfunction buildAccountToCache(cacheStorage, authority, homeAccountId, idTokenClaims, base64Decode, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {\n  logger?.verbose(\"setCachedAccount called\");\n  // Check if base account is already cached\n  const accountKeys = cacheStorage.getAccountKeys();\n  const baseAccountKey = accountKeys.find(accountKey => {\n    return accountKey.startsWith(homeAccountId);\n  });\n  let cachedAccount = null;\n  if (baseAccountKey) {\n    cachedAccount = cacheStorage.getAccount(baseAccountKey, logger);\n  }\n  const baseAccount = cachedAccount || AccountEntity.createAccount({\n    homeAccountId,\n    idTokenClaims,\n    clientInfo,\n    environment,\n    cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n    msGraphHost: authCodePayload?.msgraph_host,\n    nativeAccountId: nativeAccountId\n  }, authority, base64Decode);\n  const tenantProfiles = baseAccount.tenantProfiles || [];\n  if (claimsTenantId && !tenantProfiles.find(tenantProfile => {\n    return tenantProfile.tenantId === claimsTenantId;\n  })) {\n    const newTenantProfile = buildTenantProfileFromIdTokenClaims(homeAccountId, idTokenClaims);\n    tenantProfiles.push(newTenantProfile);\n  }\n  baseAccount.tenantProfiles = tenantProfiles;\n  return baseAccount;\n}\nexport { ResponseHandler, buildAccountToCache };","map":{"version":3,"names":["ResponseHandler","constructor","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","validateServerAuthorizationCodeResponse","serverResponse","requestState","state","createClientAuthError","stateNotFound","decodedServerResponseState","decodedRequestState","decodeURIComponent","e","invalidState","stateMismatch","error","error_description","suberror","isInteractionRequiredError","InteractionRequiredAuthError","timestamp","trace_id","correlation_id","claims","ServerError","validateTokenResponse","refreshAccessToken","errString","error_codes","serverError","status","HttpStatus","SERVER_ERROR_RANGE_START","SERVER_ERROR_RANGE_END","warning","CLIENT_ERROR_RANGE_START","CLIENT_ERROR_RANGE_END","Constants","EMPTY_STRING","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","addQueueMeasurement","PerformanceEvents","HandleServerTokenResponse","idTokenClaims","id_token","extractTokenClaims","base64Decode","nonce","nonceMismatch","maxAge","authTime","auth_time","authTimeNotFound","checkMaxAge","homeAccountIdentifier","AccountEntity","generateHomeAccountId","client_info","authorityType","requestStateObj","ProtocolUtils","parseRequestState","key_id","sshKid","undefined","cacheRecord","generateCacheRecord","cacheContext","verbose","TokenCacheContext","beforeCacheAccess","account","key","generateAccountKey","getAccount","generateAuthenticationResult","saveCacheRecord","storeInCache","afterCacheAccess","env","getPreferredCache","invalidCacheEnvironment","claimsTenantId","getTenantIdFromIdTokenClaims","cachedIdToken","cachedAccount","createIdTokenEntity","buildAccountToCache","cachedAccessToken","access_token","responseScopes","scope","ScopeSet","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","rtExpiresOn","refresh_token_expires_in","rtExpiresIn","createRefreshTokenEntity","foci","cachedAppMetadata","environment","familyId","CacheRecord","fromTokenCache","requestId","accessToken","expiresOn","extExpiresOn","refreshOn","tokenType","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","secret","keyId","keyIdMissing","signPopToken","target","asArray","Date","Number","extendedExpiresOn","appMetadata","THE_FAMILY_ID","uid","oid","sub","tid","spa_accountid","nativeAccountId","accountInfo","updateAccountTenantProfileData","getAccountInfo","canonicalAuthority","uniqueId","tenantId","idToken","fromCache","correlationId","userRequestState","cloudGraphHostName","msGraphHost","code","spa_code","fromNativeBroker","homeAccountId","clientInfo","accountKeys","getAccountKeys","baseAccountKey","find","accountKey","startsWith","baseAccount","createAccount","cloud_graph_host_name","msgraph_host","tenantProfiles","tenantProfile","newTenantProfile","buildTenantProfileFromIdTokenClaims","push"],"sources":["D:\\selvakumar\\java-chat-repo\\websocket-springboot-01\\Java-chatapp\\chatclient\\node_modules\\@azure\\msal-common\\src\\response\\ResponseHandler.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport {\r\n    ClientAuthErrorCodes,\r\n    createClientAuthError,\r\n} from \"../error/ClientAuthError\";\r\nimport { ServerAuthorizationCodeResponse } from \"./ServerAuthorizationCodeResponse\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { ServerError } from \"../error/ServerError\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AuthenticationResult } from \"./AuthenticationResult\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\r\nimport {\r\n    InteractionRequiredAuthError,\r\n    isInteractionRequiredError,\r\n} from \"../error/InteractionRequiredAuthError\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { CacheManager } from \"../cache/CacheManager\";\r\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils\";\r\nimport {\r\n    AuthenticationScheme,\r\n    Constants,\r\n    THE_FAMILY_ID,\r\n    HttpStatus,\r\n} from \"../utils/Constants\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity\";\r\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin\";\r\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext\";\r\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache\";\r\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\nimport { checkMaxAge, extractTokenClaims } from \"../account/AuthToken\";\r\nimport {\r\n    TokenClaims,\r\n    getTenantIdFromIdTokenClaims,\r\n} from \"../account/TokenClaims\";\r\nimport {\r\n    AccountInfo,\r\n    buildTenantProfileFromIdTokenClaims,\r\n    updateAccountTenantProfileData,\r\n} from \"../account/AccountInfo\";\r\nimport * as CacheHelpers from \"../cache/utils/CacheHelpers\";\r\n\r\n/**\r\n * Class that handles response parsing.\r\n * @internal\r\n */\r\nexport class ResponseHandler {\r\n    private clientId: string;\r\n    private cacheStorage: CacheManager;\r\n    private cryptoObj: ICrypto;\r\n    private logger: Logger;\r\n    private homeAccountIdentifier: string;\r\n    private serializableCache: ISerializableTokenCache | null;\r\n    private persistencePlugin: ICachePlugin | null;\r\n    private performanceClient?: IPerformanceClient;\r\n\r\n    constructor(\r\n        clientId: string,\r\n        cacheStorage: CacheManager,\r\n        cryptoObj: ICrypto,\r\n        logger: Logger,\r\n        serializableCache: ISerializableTokenCache | null,\r\n        persistencePlugin: ICachePlugin | null,\r\n        performanceClient?: IPerformanceClient\r\n    ) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param requestState\r\n     * @param cryptoObj\r\n     */\r\n    validateServerAuthorizationCodeResponse(\r\n        serverResponse: ServerAuthorizationCodeResponse,\r\n        requestState: string\r\n    ): void {\r\n        if (!serverResponse.state || !requestState) {\r\n            throw serverResponse.state\r\n                ? createClientAuthError(\r\n                      ClientAuthErrorCodes.stateNotFound,\r\n                      \"Cached State\"\r\n                  )\r\n                : createClientAuthError(\r\n                      ClientAuthErrorCodes.stateNotFound,\r\n                      \"Server State\"\r\n                  );\r\n        }\r\n\r\n        let decodedServerResponseState: string;\r\n        let decodedRequestState: string;\r\n\r\n        try {\r\n            decodedServerResponseState = decodeURIComponent(\r\n                serverResponse.state\r\n            );\r\n        } catch (e) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.invalidState,\r\n                serverResponse.state\r\n            );\r\n        }\r\n\r\n        try {\r\n            decodedRequestState = decodeURIComponent(requestState);\r\n        } catch (e) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.invalidState,\r\n                serverResponse.state\r\n            );\r\n        }\r\n\r\n        if (decodedServerResponseState !== decodedRequestState) {\r\n            throw createClientAuthError(ClientAuthErrorCodes.stateMismatch);\r\n        }\r\n\r\n        // Check for error\r\n        if (\r\n            serverResponse.error ||\r\n            serverResponse.error_description ||\r\n            serverResponse.suberror\r\n        ) {\r\n            if (\r\n                isInteractionRequiredError(\r\n                    serverResponse.error,\r\n                    serverResponse.error_description,\r\n                    serverResponse.suberror\r\n                )\r\n            ) {\r\n                throw new InteractionRequiredAuthError(\r\n                    serverResponse.error || \"\",\r\n                    serverResponse.error_description,\r\n                    serverResponse.suberror,\r\n                    serverResponse.timestamp || \"\",\r\n                    serverResponse.trace_id || \"\",\r\n                    serverResponse.correlation_id || \"\",\r\n                    serverResponse.claims || \"\"\r\n                );\r\n            }\r\n\r\n            throw new ServerError(\r\n                serverResponse.error || \"\",\r\n                serverResponse.error_description,\r\n                serverResponse.suberror\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     * @param refreshAccessToken\r\n     */\r\n    validateTokenResponse(\r\n        serverResponse: ServerAuthorizationTokenResponse,\r\n        refreshAccessToken?: boolean\r\n    ): void {\r\n        // Check for error\r\n        if (\r\n            serverResponse.error ||\r\n            serverResponse.error_description ||\r\n            serverResponse.suberror\r\n        ) {\r\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\r\n            const serverError = new ServerError(\r\n                serverResponse.error,\r\n                errString,\r\n                serverResponse.suberror\r\n            );\r\n\r\n            // check if 500 error\r\n            if (\r\n                refreshAccessToken &&\r\n                serverResponse.status &&\r\n                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&\r\n                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END\r\n            ) {\r\n                this.logger.warning(\r\n                    `executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`\r\n                );\r\n\r\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\r\n                return;\r\n                // check if 400 error\r\n            } else if (\r\n                refreshAccessToken &&\r\n                serverResponse.status &&\r\n                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&\r\n                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END\r\n            ) {\r\n                this.logger.warning(\r\n                    `executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`\r\n                );\r\n\r\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\r\n                return;\r\n            }\r\n\r\n            if (\r\n                isInteractionRequiredError(\r\n                    serverResponse.error,\r\n                    serverResponse.error_description,\r\n                    serverResponse.suberror\r\n                )\r\n            ) {\r\n                throw new InteractionRequiredAuthError(\r\n                    serverResponse.error,\r\n                    serverResponse.error_description,\r\n                    serverResponse.suberror,\r\n                    serverResponse.timestamp || Constants.EMPTY_STRING,\r\n                    serverResponse.trace_id || Constants.EMPTY_STRING,\r\n                    serverResponse.correlation_id || Constants.EMPTY_STRING,\r\n                    serverResponse.claims || Constants.EMPTY_STRING\r\n                );\r\n            }\r\n\r\n            throw serverError;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    async handleServerTokenResponse(\r\n        serverTokenResponse: ServerAuthorizationTokenResponse,\r\n        authority: Authority,\r\n        reqTimestamp: number,\r\n        request: BaseAuthRequest,\r\n        authCodePayload?: AuthorizationCodePayload,\r\n        userAssertionHash?: string,\r\n        handlingRefreshTokenResponse?: boolean,\r\n        forceCacheRefreshTokenResponse?: boolean,\r\n        serverRequestId?: string\r\n    ): Promise<AuthenticationResult> {\r\n        this.performanceClient?.addQueueMeasurement(\r\n            PerformanceEvents.HandleServerTokenResponse,\r\n            serverTokenResponse.correlation_id\r\n        );\r\n\r\n        // create an idToken object (not entity)\r\n        let idTokenClaims: TokenClaims | undefined;\r\n        if (serverTokenResponse.id_token) {\r\n            idTokenClaims = extractTokenClaims(\r\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\r\n                this.cryptoObj.base64Decode\r\n            );\r\n\r\n            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n            if (authCodePayload && authCodePayload.nonce) {\r\n                if (idTokenClaims.nonce !== authCodePayload.nonce) {\r\n                    throw createClientAuthError(\r\n                        ClientAuthErrorCodes.nonceMismatch\r\n                    );\r\n                }\r\n            }\r\n\r\n            // token max_age check\r\n            if (request.maxAge || request.maxAge === 0) {\r\n                const authTime = idTokenClaims.auth_time;\r\n                if (!authTime) {\r\n                    throw createClientAuthError(\r\n                        ClientAuthErrorCodes.authTimeNotFound\r\n                    );\r\n                }\r\n\r\n                checkMaxAge(authTime, request.maxAge);\r\n            }\r\n        }\r\n\r\n        // generate homeAccountId\r\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(\r\n            serverTokenResponse.client_info || Constants.EMPTY_STRING,\r\n            authority.authorityType,\r\n            this.logger,\r\n            this.cryptoObj,\r\n            idTokenClaims\r\n        );\r\n\r\n        // save the response tokens\r\n        let requestStateObj: RequestStateObject | undefined;\r\n        if (!!authCodePayload && !!authCodePayload.state) {\r\n            requestStateObj = ProtocolUtils.parseRequestState(\r\n                this.cryptoObj,\r\n                authCodePayload.state\r\n            );\r\n        }\r\n\r\n        // Add keyId from request to serverTokenResponse if defined\r\n        serverTokenResponse.key_id =\r\n            serverTokenResponse.key_id || request.sshKid || undefined;\r\n\r\n        const cacheRecord = this.generateCacheRecord(\r\n            serverTokenResponse,\r\n            authority,\r\n            reqTimestamp,\r\n            request,\r\n            idTokenClaims,\r\n            userAssertionHash,\r\n            authCodePayload\r\n        );\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistencePlugin && this.serializableCache) {\r\n                this.logger.verbose(\r\n                    \"Persistence enabled, calling beforeCacheAccess\"\r\n                );\r\n                cacheContext = new TokenCacheContext(\r\n                    this.serializableCache,\r\n                    true\r\n                );\r\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\r\n            }\r\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\r\n            if (\r\n                handlingRefreshTokenResponse &&\r\n                !forceCacheRefreshTokenResponse &&\r\n                cacheRecord.account\r\n            ) {\r\n                const key = cacheRecord.account.generateAccountKey();\r\n                const account = this.cacheStorage.getAccount(key, this.logger);\r\n                if (!account) {\r\n                    this.logger.warning(\r\n                        \"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\"\r\n                    );\r\n                    return await ResponseHandler.generateAuthenticationResult(\r\n                        this.cryptoObj,\r\n                        authority,\r\n                        cacheRecord,\r\n                        false,\r\n                        request,\r\n                        idTokenClaims,\r\n                        requestStateObj,\r\n                        undefined,\r\n                        serverRequestId\r\n                    );\r\n                }\r\n            }\r\n            await this.cacheStorage.saveCacheRecord(\r\n                cacheRecord,\r\n                request.storeInCache\r\n            );\r\n        } finally {\r\n            if (\r\n                this.persistencePlugin &&\r\n                this.serializableCache &&\r\n                cacheContext\r\n            ) {\r\n                this.logger.verbose(\r\n                    \"Persistence enabled, calling afterCacheAccess\"\r\n                );\r\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n\r\n        return ResponseHandler.generateAuthenticationResult(\r\n            this.cryptoObj,\r\n            authority,\r\n            cacheRecord,\r\n            false,\r\n            request,\r\n            idTokenClaims,\r\n            requestStateObj,\r\n            serverTokenResponse,\r\n            serverRequestId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    private generateCacheRecord(\r\n        serverTokenResponse: ServerAuthorizationTokenResponse,\r\n        authority: Authority,\r\n        reqTimestamp: number,\r\n        request: BaseAuthRequest,\r\n        idTokenClaims?: TokenClaims,\r\n        userAssertionHash?: string,\r\n        authCodePayload?: AuthorizationCodePayload\r\n    ): CacheRecord {\r\n        const env = authority.getPreferredCache();\r\n        if (!env) {\r\n            throw createClientAuthError(\r\n                ClientAuthErrorCodes.invalidCacheEnvironment\r\n            );\r\n        }\r\n\r\n        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);\r\n\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        let cachedIdToken: IdTokenEntity | undefined;\r\n        let cachedAccount: AccountEntity | undefined;\r\n        if (serverTokenResponse.id_token && !!idTokenClaims) {\r\n            cachedIdToken = CacheHelpers.createIdTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.id_token,\r\n                this.clientId,\r\n                claimsTenantId || \"\"\r\n            );\r\n\r\n            cachedAccount = buildAccountToCache(\r\n                this.cacheStorage,\r\n                authority,\r\n                this.homeAccountIdentifier,\r\n                idTokenClaims,\r\n                this.cryptoObj.base64Decode,\r\n                serverTokenResponse.client_info,\r\n                env,\r\n                claimsTenantId,\r\n                authCodePayload,\r\n                undefined, // nativeAccountId\r\n                this.logger\r\n            );\r\n        }\r\n\r\n        // AccessToken\r\n        let cachedAccessToken: AccessTokenEntity | null = null;\r\n        if (serverTokenResponse.access_token) {\r\n            // If scopes not returned in server response, use request scopes\r\n            const responseScopes = serverTokenResponse.scope\r\n                ? ScopeSet.fromString(serverTokenResponse.scope)\r\n                : new ScopeSet(request.scopes || []);\r\n\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            const expiresIn: number =\r\n                (typeof serverTokenResponse.expires_in === \"string\"\r\n                    ? parseInt(serverTokenResponse.expires_in, 10)\r\n                    : serverTokenResponse.expires_in) || 0;\r\n            const extExpiresIn: number =\r\n                (typeof serverTokenResponse.ext_expires_in === \"string\"\r\n                    ? parseInt(serverTokenResponse.ext_expires_in, 10)\r\n                    : serverTokenResponse.ext_expires_in) || 0;\r\n            const refreshIn: number | undefined =\r\n                (typeof serverTokenResponse.refresh_in === \"string\"\r\n                    ? parseInt(serverTokenResponse.refresh_in, 10)\r\n                    : serverTokenResponse.refresh_in) || undefined;\r\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            const extendedTokenExpirationSeconds =\r\n                tokenExpirationSeconds + extExpiresIn;\r\n            const refreshOnSeconds =\r\n                refreshIn && refreshIn > 0\r\n                    ? reqTimestamp + refreshIn\r\n                    : undefined;\r\n\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = CacheHelpers.createAccessTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.access_token,\r\n                this.clientId,\r\n                claimsTenantId || authority.tenant,\r\n                responseScopes.printScopes(),\r\n                tokenExpirationSeconds,\r\n                extendedTokenExpirationSeconds,\r\n                this.cryptoObj.base64Decode,\r\n                refreshOnSeconds,\r\n                serverTokenResponse.token_type,\r\n                userAssertionHash,\r\n                serverTokenResponse.key_id,\r\n                request.claims,\r\n                request.requestedClaimsHash\r\n            );\r\n        }\r\n\r\n        // refreshToken\r\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\r\n        if (serverTokenResponse.refresh_token) {\r\n            let rtExpiresOn: number | undefined;\r\n            if (serverTokenResponse.refresh_token_expires_in) {\r\n                const rtExpiresIn: number =\r\n                    typeof serverTokenResponse.refresh_token_expires_in ===\r\n                    \"string\"\r\n                        ? parseInt(\r\n                              serverTokenResponse.refresh_token_expires_in,\r\n                              10\r\n                          )\r\n                        : serverTokenResponse.refresh_token_expires_in;\r\n                rtExpiresOn = reqTimestamp + rtExpiresIn;\r\n            }\r\n            cachedRefreshToken = CacheHelpers.createRefreshTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.refresh_token,\r\n                this.clientId,\r\n                serverTokenResponse.foci,\r\n                userAssertionHash,\r\n                rtExpiresOn\r\n            );\r\n        }\r\n\r\n        // appMetadata\r\n        let cachedAppMetadata: AppMetadataEntity | null = null;\r\n        if (serverTokenResponse.foci) {\r\n            cachedAppMetadata = {\r\n                clientId: this.clientId,\r\n                environment: env,\r\n                familyId: serverTokenResponse.foci,\r\n            };\r\n        }\r\n\r\n        return new CacheRecord(\r\n            cachedAccount,\r\n            cachedIdToken,\r\n            cachedAccessToken,\r\n            cachedRefreshToken,\r\n            cachedAppMetadata\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    static async generateAuthenticationResult(\r\n        cryptoObj: ICrypto,\r\n        authority: Authority,\r\n        cacheRecord: CacheRecord,\r\n        fromTokenCache: boolean,\r\n        request: BaseAuthRequest,\r\n        idTokenClaims?: TokenClaims,\r\n        requestState?: RequestStateObject,\r\n        serverTokenResponse?: ServerAuthorizationTokenResponse,\r\n        requestId?: string\r\n    ): Promise<AuthenticationResult> {\r\n        let accessToken: string = Constants.EMPTY_STRING;\r\n        let responseScopes: Array<string> = [];\r\n        let expiresOn: Date | null = null;\r\n        let extExpiresOn: Date | undefined;\r\n        let refreshOn: Date | undefined;\r\n        let familyId: string = Constants.EMPTY_STRING;\r\n\r\n        if (cacheRecord.accessToken) {\r\n            if (\r\n                cacheRecord.accessToken.tokenType === AuthenticationScheme.POP\r\n            ) {\r\n                const popTokenGenerator: PopTokenGenerator =\r\n                    new PopTokenGenerator(cryptoObj);\r\n                const { secret, keyId } = cacheRecord.accessToken;\r\n\r\n                if (!keyId) {\r\n                    throw createClientAuthError(\r\n                        ClientAuthErrorCodes.keyIdMissing\r\n                    );\r\n                }\r\n\r\n                accessToken = await popTokenGenerator.signPopToken(\r\n                    secret,\r\n                    keyId,\r\n                    request\r\n                );\r\n            } else {\r\n                accessToken = cacheRecord.accessToken.secret;\r\n            }\r\n            responseScopes = ScopeSet.fromString(\r\n                cacheRecord.accessToken.target\r\n            ).asArray();\r\n            expiresOn = new Date(\r\n                Number(cacheRecord.accessToken.expiresOn) * 1000\r\n            );\r\n            extExpiresOn = new Date(\r\n                Number(cacheRecord.accessToken.extendedExpiresOn) * 1000\r\n            );\r\n            if (cacheRecord.accessToken.refreshOn) {\r\n                refreshOn = new Date(\r\n                    Number(cacheRecord.accessToken.refreshOn) * 1000\r\n                );\r\n            }\r\n        }\r\n\r\n        if (cacheRecord.appMetadata) {\r\n            familyId =\r\n                cacheRecord.appMetadata.familyId === THE_FAMILY_ID\r\n                    ? THE_FAMILY_ID\r\n                    : \"\";\r\n        }\r\n        const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\r\n        const tid = idTokenClaims?.tid || \"\";\r\n\r\n        // for hybrid + native bridge enablement, send back the native account Id\r\n        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\r\n            cacheRecord.account.nativeAccountId =\r\n                serverTokenResponse?.spa_accountid;\r\n        }\r\n\r\n        const accountInfo: AccountInfo | null = cacheRecord.account\r\n            ? updateAccountTenantProfileData(\r\n                  cacheRecord.account.getAccountInfo(),\r\n                  undefined, // tenantProfile optional\r\n                  idTokenClaims\r\n              )\r\n            : null;\r\n\r\n        return {\r\n            authority: authority.canonicalAuthority,\r\n            uniqueId: uid,\r\n            tenantId: tid,\r\n            scopes: responseScopes,\r\n            account: accountInfo,\r\n            idToken: cacheRecord?.idToken?.secret || \"\",\r\n            idTokenClaims: idTokenClaims || {},\r\n            accessToken: accessToken,\r\n            fromCache: fromTokenCache,\r\n            expiresOn: expiresOn,\r\n            extExpiresOn: extExpiresOn,\r\n            refreshOn: refreshOn,\r\n            correlationId: request.correlationId,\r\n            requestId: requestId || Constants.EMPTY_STRING,\r\n            familyId: familyId,\r\n            tokenType:\r\n                cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\r\n            state: requestState\r\n                ? requestState.userRequestState\r\n                : Constants.EMPTY_STRING,\r\n            cloudGraphHostName:\r\n                cacheRecord.account?.cloudGraphHostName ||\r\n                Constants.EMPTY_STRING,\r\n            msGraphHost:\r\n                cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\r\n            code: serverTokenResponse?.spa_code,\r\n            fromNativeBroker: false,\r\n        };\r\n    }\r\n}\r\n\r\nexport function buildAccountToCache(\r\n    cacheStorage: CacheManager,\r\n    authority: Authority,\r\n    homeAccountId: string,\r\n    idTokenClaims: TokenClaims,\r\n    base64Decode: (input: string) => string,\r\n    clientInfo?: string,\r\n    environment?: string,\r\n    claimsTenantId?: string | null,\r\n    authCodePayload?: AuthorizationCodePayload,\r\n    nativeAccountId?: string,\r\n    logger?: Logger\r\n): AccountEntity {\r\n    logger?.verbose(\"setCachedAccount called\");\r\n\r\n    // Check if base account is already cached\r\n    const accountKeys = cacheStorage.getAccountKeys();\r\n    const baseAccountKey = accountKeys.find((accountKey: string) => {\r\n        return accountKey.startsWith(homeAccountId);\r\n    });\r\n\r\n    let cachedAccount: AccountEntity | null = null;\r\n    if (baseAccountKey) {\r\n        cachedAccount = cacheStorage.getAccount(baseAccountKey, logger);\r\n    }\r\n\r\n    const baseAccount =\r\n        cachedAccount ||\r\n        AccountEntity.createAccount(\r\n            {\r\n                homeAccountId,\r\n                idTokenClaims,\r\n                clientInfo,\r\n                environment,\r\n                cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\r\n                msGraphHost: authCodePayload?.msgraph_host,\r\n                nativeAccountId: nativeAccountId,\r\n            },\r\n            authority,\r\n            base64Decode\r\n        );\r\n\r\n    const tenantProfiles = baseAccount.tenantProfiles || [];\r\n\r\n    if (\r\n        claimsTenantId &&\r\n        !tenantProfiles.find((tenantProfile) => {\r\n            return tenantProfile.tenantId === claimsTenantId;\r\n        })\r\n    ) {\r\n        const newTenantProfile = buildTenantProfileFromIdTokenClaims(\r\n            homeAccountId,\r\n            idTokenClaims\r\n        );\r\n        tenantProfiles.push(newTenantProfile);\r\n    }\r\n    baseAccount.tenantProfiles = tenantProfiles;\r\n\r\n    return baseAccount;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}